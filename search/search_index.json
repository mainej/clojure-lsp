{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"clojure-lsp # A Language Server for Clojure(script). Taking a Cursive-like approach of statically analyzing code. homepage \u2022 features \u2022 installation \u2022 settings \u2022 clients \u2022 troubleshooting \u2022 support us Overview # The goal of this project is to bring great editing tools for Clojure/Clojurescript to all editors. It aims to work alongside you to help you navigate, identify and fix errors, perform refactors and much more! You will get: Autocomplete Jump to definition Find references Renaming Code actions Errors Automatic ns management Refactorings Code lens Semantic tokens (syntax highlighting) Call hierarchy Java interop For all available documentation, check the official website . Also, clojure-lsp doesn't need to run in a editor, for more information check the API documentation section . Contribution # Contributions to clojure-lsp are very welcome! You can open an issue or a PR and we'd love to help. Support the project # clojure-lsp has more than 18.000 lines of code, to keep all of this working, we need to help the community on a lot of issues and implement new features. As a LSP server, this project is the base for Clojure clients like Emacs(lsp-mode), VSCode(Calva), vim and other editors. You can help us keep going and improving it by supporting the project , the support helps to keep the project going and being updated and maintained. Thank you to Clojurists Together which is sponsored this project during Q3 2021 and Q1 2022 Gold sponsors # pitch-io Pitch 180seg 180\u00ba Insurance Sponsors # Special thanks to Eccentric-J for the clojure-lsp logo","title":"Overview"},{"location":"#clojure-lsp","text":"A Language Server for Clojure(script). Taking a Cursive-like approach of statically analyzing code. homepage \u2022 features \u2022 installation \u2022 settings \u2022 clients \u2022 troubleshooting \u2022 support us","title":"clojure-lsp"},{"location":"#overview","text":"The goal of this project is to bring great editing tools for Clojure/Clojurescript to all editors. It aims to work alongside you to help you navigate, identify and fix errors, perform refactors and much more! You will get: Autocomplete Jump to definition Find references Renaming Code actions Errors Automatic ns management Refactorings Code lens Semantic tokens (syntax highlighting) Call hierarchy Java interop For all available documentation, check the official website . Also, clojure-lsp doesn't need to run in a editor, for more information check the API documentation section .","title":"Overview"},{"location":"#contribution","text":"Contributions to clojure-lsp are very welcome! You can open an issue or a PR and we'd love to help.","title":"Contribution"},{"location":"#support-the-project","text":"clojure-lsp has more than 18.000 lines of code, to keep all of this working, we need to help the community on a lot of issues and implement new features. As a LSP server, this project is the base for Clojure clients like Emacs(lsp-mode), VSCode(Calva), vim and other editors. You can help us keep going and improving it by supporting the project , the support helps to keep the project going and being updated and maintained. Thank you to Clojurists Together which is sponsored this project during Q3 2021 and Q1 2022","title":"Support the project"},{"location":"#gold-sponsors","text":"pitch-io Pitch 180seg 180\u00ba Insurance","title":"Gold sponsors"},{"location":"#sponsors","text":"Special thanks to Eccentric-J for the clojure-lsp logo","title":"Sponsors"},{"location":"CHANGELOG/","text":"Changelog # Unreleased # General Improve settings documentation. Fix completion performance regression from previous release. Consider .bb and .cljd files on watched file changes. #906 Bump to clojure 1.11.0 Improve analysis query performance as a whole for lots of features. #916 Bump clj-kondo to 2022.04.08 fixing semantic tokens for :require , :refer and :as . #1609 Move lsp4clj to outside clojure-lsp to its own repo/jar release. Fix local files outside source-paths not being linted even if opened/changed. Consider filename + lastModified as checksum for external files, avoiding analyzing it if analysis is already present. graalvm: Compile static linux with --musl for better compatibility. #868 Editor Introduce ALPHA move-form command. #566 Rename \"Move coll entry up/down\" to \"Drag forward/backward\", matching Calva/Paredit terminology drag: clauses move intuitively in clojure.test/are drag: top-level forms can be dragged #891 Improve completion performance for most cases, reducing time to compute clj/cljs core symbols. completion: suggest functions defined in Clojure 1.10 and 1.11 completion: Fix to no require extra ns when alias is already required. #920 2022.03.31-20.00.20 # Fix URI resolver on java JDK logic. Fix zipfile scheme when finding external deps. 2022.03.31-14.21.14 # Add java class find-definition support, decompiling .class files when available. #762 Add JDK source discoverability feature, searching for installed JDK for later analyze with clj-kondo and support java classes interop. Add :java :download-jdk-source? setting to download JDK source after startup if not cached before globally or found locally. Disabled by default. Avoid high CPU usage and freezes by more efficiently finding referenced files to notify on file change. #844 @mainej Bump clj-kondo to 2022.03.10-20220331.135739-32 improving java analysis and fixing a critical regression for re-frame. #888 This release was supported by Clojurists Together 2022.03.26-18.47.08 # Fix unused-public-var not considering excluding comments, changing async-custom-lint? setting to false. 2022.03.25-12.02.59 # General Fix cljfmt settings merge during refresh/classpath configs merge to avoid multiple config vectors on same symbol. Fix install script for aarch64. #794 Fix handling cljfmt config files that end in .clj https://github.com/weavejester/cljfmt/issues/190 parser: more efficiently seek to cursor position, improving performance especially in large files. #793 @mainej Fix clean-ns not sorting properly node requires for cljs. #815 Fix move-to-let to ensure locals don't move out of scope. #830 Improve logic around require suggestions. #837 Enhance move-to-let to introduce and expand let if an existing one doesn't exist. #829 Bump org.clojure/clojure to 1.11.0 . Fix move-coll-entry to maintain cursor position instead of a range. #862 Clean ns automatically after adding missing require/imports, enabled by default under new :clean :after-ns-refactor flag. #558 Editor extract-function: Fix wrong args when extracting from multi-arity fn. #683 extract-function: Fix wrong args when extracting after a local usage. #812 @mainej move-coll-entry: clauses move intuitively in assoc , case , cond , and similar functions. #780 @mainej move-coll-entry: fix NPE when when invoked from top-level #803 @mainej Generate stubs async after startup, improving startup time. #788 Improve and add lots of new snippets following practicalli config. #797 Improve how watched new files are analyzed avoiding infinite loops and performance issues. #796 Avoid infinite loops when several files are changed simultaneously. #796 @mainej Fix \"incoming call hierarchy\" not considering usages inside defmethods. #808 range-formatting: more efficiently locate extent of range and reduce number of calls to cljfmt, improving performance especially when formatting large ranges. #795 @mainej cycle-fn-literal: new feature convert between function-literal syntaxes (fn [] ...) <-> #(...) . #774 Add find-implementation feature to defmulti and defmethod . #751 Make find-implementation of defprotocol names find its implementations and find-implementation on deftype / defrecord methods find other implementations. Add new code action Introduce let for existing command. #825 Make find-implementations consider reify . #827 Fix namespace on file creation when nested source-paths are available. #832 unused-public-var: fix to show warnings on vars defined with declare. #840 unused-public-var: large performance improvements, especially for large projects. #861 @mainej API/CLI Extract lsp4clj as a seperate library. #807 @Cyrik Supported by Scarlet Fix inconsistency with clean-ns/format not copying kondo configs. This release was supported by Clojurists Together 2022.02.23-12.12.12 # General Use :source-aliases setting during default deps.edn and lein project-spec aliases, avoiding the need to configure a whole project-spec just because of a additional alias. Exclude from unused-public-var linter vars with metadata ^:export . #753 Fix clean-ns multiple refers sort when there is a alias before the refers. Bump clj-kondo from 2022.01.15 to 2022.02.09 adding support for implementation analysis and more improvements. Medium performance improvement during startup when unused-public-var linter is disabled. Medium performance improvement during startup on unused-public-var calculation parallelizing calculations. Small performance improvement on code actions calcullation. Add :use-source-paths-from-classpath setting defaulting to true, which makes clojure-lsp do not manually discovery source-paths but get from classpath excluding jar files and paths outside project-root. #752 #551 Improve completion performance when all clojure.core or cljs.core symbols are valid completions. #764, #771 @mainej Fix scenarios where the lint findings in individual files differed from what you'd expect based on the .clj-kondo/config.edn settings. Add :exclude-regex and :exclude-when-definted-by-regex to :clojure-lsp/unused-public-var linter. Bump org.clojure/clojure to 1.11.0-rc1 . Editor Fix exception during code actions calculation when in a invalid code of a map with not even key-pairs. Don't return diagnostics for external files like files on jar dependencies, avoiding noise on lint when opening dependencies. Support finding implementations of defprotocol and references of defrecord/deftype, implementing LSP method textDocument/implementation . #656 Make the actions and commands aware of when they were invoked from comments or whitespace. This will allow individual refactorings to be more deliberate about how they handle comments and whitespace. #716 @mainej Correctly position the cursor after calling move-coll-entry-down on an entry with leading comments. #758 @mainej Don't return completions when invoked from a comment, avoiding performance problems. #756 Fix small anomalies in parameter names of extracted private functions. #759 @mainej Add semantic tokens for protocol implementations methods like defrecord and deftype. Small performance improvevement on code lens calculation using transducers. API/CLI Small performance improvement to format , clean-ns , diagnostics , and rename via parallelizing parts of the logic. Fix edn->json parser of serverInfo/raw for Calva use cljfmt configuration. #763 Add :cljfmt-raw config to serverInfo/raw for Calva. #768 Add support for passing specific --filenames for most actions. #775 This release was supported by Clojurists Together 2022.02.01-20.02.32 # General Fix classpath hash regression introduced by last release 2022.02.01-16.53.14 # General Migrate project from depstar -> tools.build. #711 Improve classpath hash to consider invaliding cache when local root deps was changed. Replace datalevin cache db with transit. #703 Bump Graalvm from 21.3.0 to 22.0.0.2 improving binary performance/size Update XDG_CONFIG_HOME to clojure-lsp directory in doc/settings.md Editor Support going to namespace definition on an alias. #706 Add LSP textDocument/declaration , for now adding the making possible navigate to alias and namespaces declared on the namespace. #680 Fix removal of file analysis on didClose for external files like jars. #717 Fix cursor not moving when using code actions that move the cursor automatically. Fix additional-snippets to work on top-level forms as well. Fix resolve completion item not returning insertText. #719 @Cyrik Remove support for LSP codeAction/resolve . It added complexity and was not used in a way that improved performance of the action menu. #722, #725, #726 Fix create public function refactoring not working when function is not a function call. 2022.01.22-01.31.09 # General Fix freezing in some cases during clojure-lsp startup linting. #708 2022.01.20-14.12.43 # General Bump clj-kondo to 2022.01.15 . Add :classpath to serverInfo command for downstream usages. Fix issues in extract-function that arise when operating over .cljc files. Add setting :copy-kondo-configs? to allow disable auto clj-kondo config copy, enabled by default. #694 Lint unused public keywords, like unused re-frame events/subs. #691 Fix rename of namespaced keywords -> aliased keywords. #665 Huge refactor on clojure-lsp codebase, spliting code into submodules, this made possible remove a lot of deps from API jar and help separate clojure-lsp features in the future. #658 Send testTree notification for all project test files after clojure-lsp start. #697 Editor Improve 'create function' refactor code action handling multiple cases. #682 Fix 'resolve macro as ...' code action not working. Fix showDocumentRequest issues when triggered via some refactor code action. Add new code actions + commands Move coll entry down and Move coll entry up to move entries within collections. #684, #701 API/CLI Make format , clean-ns and rename features not need to scan whole classpath, analyzing only project code improving performance a lot. 2022.01.03-19.46.10 # Catch clj-kondo prints to stdout and log to clojure-lsp log file avoiding crashes on some clients like vscode/Calva. 2022.01.03-15.41.19 # General Fix some analysis conflicts regarding custom-async-lint? feature introduced on latest release causing outdated analysis and some deadlocks. Editor Fix inline symbol code action regression from previous releases. #678 Fix expand let refactor duplicating variables in some cases. #676 Add completion support to potemkin usages of a namespace. API/CLI Wait for db cache upsert before end proccess, avoiding the need to re-lint whole classpath on next api/cli runs. Fix the need to use :raw? true on babashka pod usage. 2021.12.20-00.36.56 # General Bump clj-kondo to 2021.12.19 , supporting auto-load configs, improving potemkin support, adding more linters and more. Merge :cljfmt settings with :cljfmt-config-path if file path exists. Avoid high CPU and lockup when clj-kondo throws exceptions. #671 Allow absolute paths in deps.edn :local/root #672 Fix clojure-lsp not loading for some mono-repo cases, improving local/root support for polylith projects. #673 Avoid infinite loop because of cyclic dependencies on deps source-path discovery. Add babashka pod. #555 Editor Change call hierarchy to return selection range of usage, not function definition. Return edits in codeAction/resolve responses rather than commands . #655 Improve :linters :clj-kondo :async-custom-lint? to avoid infinite loops and default to true . Add new custom LSP feature Test Tree , which shows all test hierarchy of a file. #653 Improve function name finding to consider other function definition types for some features. #666 Make textDocument/hover return the correct range from LSP spec, the element range instead of the element scope range. API/CLI Exit process if any error during classpath lookup. Opt-out via :api :exit-on-errors? flag. 2021.12.01-12.28.16 # General Add support for LSP method textDocument/prepareRename which it's the proper way to check if the rename will work correctly. #642 Expose new custom method clojure/cursorInfo/raw for custom hack on current cursor information code. #645 Support stub generation using clj-easy/stub , adding analysis and linting support for closed sources codes like Datomic. Check :stubs settings for more details. #637 Handle config deep merge differently for collections, concating instead of overwriting. Fix unnecessary exception thrown on graal images during startup. Support deps.edn :local/root source-paths discovery, improving support for monorepo projects like polylith . #652 New setting value for :clean :sort :require : :lexicographic . #654 Bump clj-kondo to 2021.10.20-20211126.151305-16 . Editor Support completion on aliased keywords. #649 Add new Sort map keys refactoring code action. #651 Add new Create function code action, allowing to create a function on a existing namespace or creating a new namespace + the function. #646 Improve Extract function refactoring to consider comments above current function. Experimental: new :linters :clj-kondo :async-custom-lint? setting, when true, scan unused-public-vars async improving lint/analysis UI feedback for huge buffers (> ~1000 lines). Default false . This release was supported by Clojurists Together 2021.11.16-16.52.14 # General Improve rename feature to not heavily rely on valid source-paths for most cases. Fix setTrace exception logs for graalvm native images. Huge improvements on namespaces renames and namespaces references find. #573 Fix/Remove warnings during datalevin access. Improve freezing for some MacOS cases. #631 Bump clj-kondo to 2021.10.20-20211116.110002-7 improving code parsing and other fixes. Editor Fix \"Add require\" code actions adding multiple requires instead of the selected. Improve \"Add require\" wording, making it easier to understand what each different action will do. Smart check all available refers to require, adding refer options to Add require code actions. #627 Big improvements on keyword completions. #630 Add setting keep-parens-when-threading? to keep parens for single arity functions when threading. #636 Avoid adding duplicate requires when adding a new require via code action. #640 Improve common known snippets to replace completion items, improving completion UX. #638 This release was supported by Clojurists Together 2021.11.02-15.24.47 # General Bump Graalvm from 21.2.0 to 21.3.0 improving binary performance/size Fix wrong parse of code when code contains namespaced maps like #:foo{:bar 1} . This issue was affecting a lot of features for example code actions. Bump datalevin from 0.5.26 to 0.5.27. Improve semantic tokens for dynamic vars, function definitions, namespaced and aliased keywords. Fix bug where :source-paths settings could be hot-reloaded with wrong-value. Editor Deprecates setting :show-docs-arity-on-same-line? in favor of :hover :arity-on-same-line? . Add support to new LSP LinkedEditingRange feature. #341 Improve suggested Add require ... code actions, this should make clojure-lsp smarter when user wants to add a missing require. #614 Change :notify-references-on-file-change default from false to true , we had some performance improvements and I've been testing this for some time now and didn't see any new issues with that. This should improve a lot the UX when user change any code that is references on other files, updating the diagnostics for those files as well. Improve rename feature UX to output errors when it's not possible rename. Add support for window/showDocument LSP method, used on create-test command/code action after creating the test to show the test file. Add new Unwind thread once and Unwind whole thread code actions to undo a thread call. Improve code actions performance requesting async all actions. Add new LSP custom method clojure/clojuredocs/raw which takes a symbol and a namespace (both strings) and returns any Clojuredocs entry found, otherwise null . Fix missing keywords rename/references for destructured keywords. CLI Show error/warning message when a classpath scan fail during analysis. Fixes #626 Add coloring to diagnostics output matching diagnostic severity. This release was supported by Clojurists Together 2021.10.20-16.49.47 # Editor Hot fix clojuredocs on graalvm native image. Bump clj-kondo to 2021.10.20-20211020.123254-3 to fix a specific issue with cljs. Implement support to return to client LSP Errors, making user UX better since clojure-lsp can return specific errors for specific exceptions. 2021.10.20-13.04.11 # General Improve intialization feedback report messages. Consider dev and test alias for deps.edn projects as project-specs during classpath lookup. #586 Avoid scanning source-paths twice, as it was being considered as part of external classpath as well. Change cache db from sqlite to datalevin for faster startup + better graalvm compatibility. Make the cache analysis save async to make startup faster. Support Auto refresh settings memoizing with a ttl of 1 second avoiding the need of restarting server when changing configs. #502 Bump clj-kondo adding new gen-class linter and other fixes/improvements. Fixes #589 Remove unused duplicate require if any. #527 Fix crash on clean-ns when ns contains comments. Improve project analysis filter to check source-paths. #597 Editor Add reference code lens for ns forms. #578 Fix expand-let bug that occurs when a list form precedes let. #590 Add new command to create test for function at point. #582 Add new code action to create test for current function/var Add private to documentSymbol to make clear that a var or function is private . Add new code action Suppress xxx diagnostic , adding clj-kondo comment code to ignore the diagnostic. #591 Add more semantic tokens: aliases for macros, variable and function definitions. Add clojuredocs information during symbol hover. #571 This release was supported by Clojurists Together 2021.09.30-15.28.01 # Editor Hot fix hover content wrong type hinting. 2021.09.30-12.28.16 # General Use lower-case for refer/import/require sorting. #560 #561 Avoid removing comments when sorting/cleaning namespace. #559 Break lines when sorting refers along with then new :clean :sort :refer :max-line-length setting with a default of 80 . #562 Deprecate lens-segregate-test-references in favor to :code-lens :segregate-test-references Check for a default .cljfmt.edn config file for cljfmt config settings if no :cljfmt-config-path was provided. #563 Bump clj-kondo to 2021.09.25 fixing false-positives with potemkin import-var analysis. Re-scan whole project if any clj-kondo config changed for better consistence. #331 Fix clojure-lsp not initializing when empty project.clj . #579 Support finding config in classpath via new setting :classpath-config-paths [\"my-org/my-lib\"] . #580 Editor Fix resolve macro as code action after regression introduced recently. Fix unused-public-var not being suppressed during project startup. #554 Improve hover feature to return elements when inside a function call. #569 Fix create-private-function command and code action to consider when new function is inside thread macros. Support $/progress LSP feature, sending notifications for client when server is starting, improving the feedback for the user. Improve semantic tokens support for java classes and methods. API/CLI Support renaming namespaces as well with rename feature. Use relative paths instead of absolute paths on diff messages. Add analyze-project! to analyze whole project only and cache analysis, useful for REPL usage for example. Follow same exit status from clj-kondo for diagnostics feature. #572 Improve start project feedback reporting the percentage and specific message. This release was supported by Clojurists Together 2021.09.13-22.25.35 # Editor Rollback change on didChangeWatchedFiles for :change events, avoiding outdated changes overwriting newer changes. 2021.09.13-19.32.00 # General Create .clj-kondo folder if not exists in project root. #528 Fix exception when :clojure-lsp/unused-public-var linter is :off . #546 Bump clj-kondo to 2021.08.07-20210903.210340-28 to fix a false-positive with potemkin. https://github.com/clj-kondo/clj-kondo/issues/1370. Bump clj-kondo to 2021.08.07-20210909.131804-29 fixing issues with built-in clj-kondo cache not present on graalvm binaries. #548 Exclude cljs.test/deftest from unused public vars linter. Migrate default db file from .lsp/sqlite.db to .lsp/.cache/sqlite.db , this is necessary as in the future we will replace sqlite with other db implementation, for users they just need to consider/gitignore the .lsp/.cache folder, this way any next change on db implementations or any other cache will not affect user. Auto migrate existing .lsp/sqlite.db to new .lsp/.cache/sqlite.db to avoid unnecessary project re-scan. Deprecates :sqlite-db-path in place of :cache-path . Editor Fix didChangeWatchedFiles to correctly create the file on server, properly change file content and re-scan with clj-kondo, or remove file analysis. This should improve LSP analysis reliability when changing files outside the editor. #536 Improve completion only showing valid local vars for current cursor. Improve completion sorting adding priority to each item, showing most used symbols like variables and functions first before other completion items. API/CLI New diagnostics command, which return all diagnostics found by clojure-lsp (using clj-kondo). Check the API section for more details. This release was supported by Clojurists Together 2021.09.04-17.11.44 # Hotfix java classes not present on jar, required for clojure-lsp downstreams. 2021.09.03-00.42.46 # General Improve logging during startup for better troubleshooting. Refactor allowing calls to clojure-lsp.main/run! for manually passing args, useful for lein-clojure-lsp for example. Internal: Move graalvm configuration to sqlite-jdbc. Recognize deftest as function definition form for refactoring features like extract-function . Bump Graalvm from 21.1.0 to 21.2.0 API/CLI Use clj-kondo custom lint for API as well, required for correct diagnostics API feature. Editor Fix regression, custom source-paths from initializationOptions were not being parsed correctly. #537 Documentation New domain for documentation and webpage https://clojure-lsp.io 2021.08.24-14.41.56 # General Fix classpath scan when classpath has other things like new lines or warning message besides the classpath. Fixes #523 Improve clean-ns to remove empty reader conditionals( #?(:clj) or #?@(:clj []) on ns form) after cleaning requires/imports. Fix clean-ns false-positives removals to cljc files when the alias/refer/import is being used inside a reader conditional. Add new setting :linters :clj-kondo :ns-exclude-regex which allows exclude diagnostics/findings for namespaces matching that regex. Fix merge of configs resolved for projects with multiple configurations in parent folders and subprojects. Docs Improved the settings docs with a new link to a file with all available clojure-lsp settings. 2021.08.16-19.02.30 # Fix clojure-lsp --version 2021.08.16-14.47.54 # General Fix wrong parse of source-paths for bb.edn when :paths contains symbols not only strings. #507 Bump clj-kondo to fix a issue with clojure-lsp running in a lein process. Editor Fix find-definition in jars for cljc files where the var is available on both cljs and clj files. #509 Add clojure.core.async common vars to common-refers to be required via code action. Remove diagnostics when files are deleted, properly cleaning server. #513 Don't add ns form to blank edn files. #515 Fix initializationOptions parsing for some clients. #516 Fix refactor 'add missing refer' when there is already that namespace with a alias but no refers. Improve :notify-references-on-file-change performance and use-cases, still disabled by default for some time. API Rollback printing only via CLI to work with API as well. (can be disabled via :raw? option) Support for release of lein-clojure-lsp 2021.08.05-19.36.09 # Bump clj-kondo to fix window path issues with analysis. Fix issue with references code lens for vim. 2021.08.05-18.25.54 # Fix async project lint after startup for huge projects. #506 Fix :lint-project-files-after-startup? to be considered before clojure-lsp lint unusued public vars. Fix excluded symbols for code lens, making clojure-lsp check clj-kondo config as well for the :clojure-lsp/unused-public-var excludes 2021.08.03-13.33.03 # General Parse correctly unescaped URIs sent from clients like vim avoiding errors on some features. Bump clj-kondo fixing analysis position issue with declare , making rename and other features work. Don't use PowerShell profiles on Windows when analyzing classpath. Fixes https://github.com/BetterThanTomorrow/calva/issues/1050 Support babashka classpath and source-paths discovery via bb.edn file. (needs babashka >= 0.5.1) Editor Add :hover :hide-file-location? settings option to disable displaying the source path on hover. Use new clj-kondo :custom-lint-fn for the :unused-public-var , this should improve performance and give the ability to suppress unused vars via code with #_{:clj-kondo/ignore [:clojure-lsp/unused-public-var]} or #_:clj-kondo/ignore 2021.07.28-14.24.06 # General Minor fix on the analysis queries comparison. Improve GraalVM configuration to use direct/less configurations. Bump clj-kondo 2021.06.18 -> 2021.07.28 which adds support for macroexpanding. Editor Fix outgoing/incoming call hierarchy when vars are outside project/external jars. Fix completion of aliases without var names typed yet, for example: string/ API/CLI Fix filename in diffs with dry option. Add coloring to diffs following git diff. Add ns-exclude-regex for commands that check whole project, allowing to exclude certain namespaces via regex. 2021.07.19-14.46.52 # General clean-ns now sorts ns children forms according to the ClojureStyleGuide, at the moment moving require form before import form, enabled by default under flag :clean :sort :ns setting. Improve startup error handler and logging during project analysis. Related to #484 Performance improvements using transducers on analysis queries. Fixed auto-resolve source-paths for lein projects that get source-paths dynamically, clojure-lsp will use the default source-paths for these cases Editor Improve hover output, both markdown and plain text forms. Allow calling thread-first/last and thread-first-all/last-all from within the list. Improve resolve-macro-as messages and default excluded symbols. API/CLI Fix empty XDG_CONFIG_HOME not defaulting to $HOME/.config #474 Improve verbose logging setting. 2021.07.12-12.30.59 # Editor Make semantic-tokens return no token for unknown symbols which has :clj-kondo/unknown-namespace on its analysis. Fix file uri location when hovering a symbol. Add reference code lens to keyword definitions, e.g. re-frame.core/reg-sub . Add semantic-tokens debug information to cursor-info response. API/CLI Fix when ns form does not match filename. #466 Fix errors with project-root on graalvm binary Improve API usage avoiding exceptions and returning just data instead. Improve analysis cache to multiple API calls. Add new --raw option allowing to display only raw data. Useful to integrate with other tools like reviewdog. 2021.07.05-20.31.12 # API/CLI Add --verbose option for debugging purposes. Fix usage as library parsing :exec-args correctly 2021.07.05-15.12.14 # General Add :clean :sort settings option to disable sorting during clean-ns . Add :keep value to :ns-indent-blocks-indentation setting to don't change indentation during clean-ns . Deprecate install-latest-clojure-lsp.sh in place of install new script. Improve source paths discoverability for leiningen projects following the same rules as deps.edn projects. For more information, check the settings section . API/CLI Add --dry option to commands, useful to print only diffs instead of making changes. Check the new setup-clojure-lsp Github Action to run clojure-lsp on CI. Add format feature using cljfmt. Now, every release is available in clojars as com.github.clojure-lsp/clojure-lsp . 2021.07.01-19.49.02 # Fix --project-path option for API. Add --log-path option to API. 2021.07.01-13.46.18 # Fix find-references and references lens for defrecord . Improve clean-ns refactoring following the Clojure style guide. Fix clean-ns corner case issue where it would replace the :as value with the :refer value. Deprecate :keep-require-at-start? in favor of :clean :ns-inner-blocks-indentation with default value of :next-line . Bump org.xerial/sqlite-jdbc from 3.34.0 to 3.36.0. Avoid adding duplicated namespace for new blank files. Add API / CLI support, form more information check the API section. 2021.06.24-14.24.11 # Fix missing LSP 3.16 graalvm reflection configs. #452 2021.06.24-01.20.01 # Fix graalvm reflect config for LSP 3.16 protocol. #449 Use last definition when showing signature help. #446 Create 2 new LSP custom methods: clojure/serverInfo/raw and clojure/serverInfo/log deprecating old commands server-info and cursor-info , check the documentation for more information. Add :final-settings to serverInfo methods. #450 2021.06.21-14.30.54 # Avoid removing whole require if unused refer but with used alias during clean-ns. #447 Bump cljfmt 0.7.0 -> 0.8.0. Fixes #266 Bump clj-kondo 2021.06.01 -> 2021.06.18 2021.06.14-17.00.47 # Improve source paths discoverability for deps.edn projects. Adds :source-aliases for customization. For more information, check the settings section . 2021.06.01-16.19.44 # Fix graalvm issue on completionItem InsertTextMode Bump clj-kondo and rewrite-clj to latest releases. 2021.05.27-17.42.34 # Fix corner case error with project paths with spaces or other special characters. #437 Drastically improve didOpen performance, improving kondo findings parsing and making linting async avoiding blocking some editors. #435 Fix :auto-add-ns-to-new-files? flag always being considered as true . #436 2021.05.22-16.50.45 # Fix completion item kind of clojure core items. Fixes #426 Fix graalvm reflect config for SublimeText - #430 Improve code lens for segregated code lens when on test files. 2021.05.14-15.26.02 # Include non full qualified vars on unused-public-var exclude filter. Improve hover documentation: use correct markdown for docstrings; remove unnecessary new lines; add link to filename location. Rollback full text changes on last release and change approach for a temporary fix. #424 2021.05.06-19.44.00 # Quick fix full text changes to handle it sync for semantic tokens Segregate main references from test references with option to disable via lens-segregate-test-references 2021.04.27-20.17.45 # Significantly improve the performance of workspace symbol filtering/searching. See relevant commit . Always sort refers when clean-ns. Add support for installing with homebrew on Linux. Bump clj-kondo to 2021.04.24-20210426.144134-2 adding support for finding re-frame by keyword. Fixes #411 Fix find definition going to declare - Fixes #340 Remove common already known clojure macros from Resolve macro as code action. 2021.04.23-15.49.47 # Improve resolve-macro-as command to check and log if couldn't resolve the macro. Improve workspace symbol filtering/searching. Now, the sole candidates shown are guaranteed to include all the characters contained in the filter/search string. Add more tokens to semantic tokens: keywords, functions/var usages, java classes, local variables. Bump Graalvm from 21.0.0 to 21.1.0 Bump clj-kondo to 2021.04.23 fixing some keywords corner cases. 2021.04.13-12.47.33 # Add common snippets on completion. Check all available snippets here . Add support for custom snippets via :additional-snippets . Check here for more information. - Fixes #403 Bump lsp4j from 0.11.0 -> 0.12.0 2021.04.07-16.34.10 # Fix renaming keywords in cljc files producing duplicate edits. After project startup, publish all project only diagnostics. This is a approach done by other LSPs to make work features like Project errors . Feature flag via lint-project-files-after-startup? with default true . Add experimental support for aarch64 linux native binary Fix formatting issues with a regression introduced on a previous release. - Fixes #339 and #396 2021.04.03-18.43.55 # Fix textDocument/workspaceSymbols filter not working on native binaries. Report duplicate linters as default, can be disabled via :linters :clj-kondo :report-duplicates - Fixes #390 Bump rewrite-clj to 1.0.605-alpha to fix exceptions when on clojure files with babashka interpreter on first line. Bump clj-kondo 2021.04.01-20210402.215253-6 to fix bug https://github.com/clj-kondo/clj-kondo/issues/1246 2021.03.30-20.42.34 # Bump clj-londo 2021.03.22-20210327.192113-4 - Fixes #385 Add support for outgoing call hierarchy - Fixes #384 Improve and fix missing completion item kinds. 2021.03.26-23.41.07 # Bump clj-kondo 2021.03.22-20210324.110254-3 - Fixes #382 [graalvm] Fixes Unable to invoke no-args constructor for class org.eclipse.lsp4j.ShowDocumentCapabilities error. Fix/enhance keyword rename - #383 2021.03.24-00.41.55 # Migrate from lein to deps.edn Bump clj-kondo to 2021.03.22 Fix clean-ns sorting according to symbols not brackets - Fixes #380 Fix missing graalvm reflect config for CompletionItemTextEdit - Fixes #381 2021.03.21-23.29.19 # Add code action 'resolve macro as', it requires client to fill the chosen macro and clj-kondo config file. Bump rewrite-clj to 1.0.594-alpha Bump data.json to 2.0.1 Bump lsp4j to 0.11.0 2021.03.18-19.23.41 # Add support for diagnostic tags: deprecated and unnecessary. Fix wrong textDocument/documentHighlight for function local-usages. Use new clj-kondo copy-configs flag to copy hooks during lint. Bunp clj-kondo to fix unused public linter check for :exclude-when-defined-by 2021.03.16-20.28.06 # Fix server not analyzing after a wrong code on cljs files - #367 Rollback incremental didChange adding a new :text-document-sync-kind setting with :full as default. 2021.03.14-23.22.46 # Fix completion inside refers, re-add support for it - Fixes #364 Change range of expression functions clj-kondo diagnostics to avoid collision with function signature. 2021.03.06-17.05.35 # Fix incremental didChange, debouncing distincting by uri, fixing some inconsistent file changes when multiple files are changed at same time (rename, iedit, etc). Make unused-public-var ignore -main public functions. Add :exclude-when-defined-by option to unused-public-var linter, check settings documentation for more information. 2021.03.05-13.35.47 # Fix clojure-lsp lint crash when analyzing specific macros with clj-kondo hooks. Fix didChange for Nvim client. Add new clojure-lsp linter: unused-public-var - Fixes #359 Add option to disable clj-kondo linter, check settings documentation for more details. 2021.03.01-19.18.54 # Bump clj-kondo fixing issues on require form not being analyzed. Fix textDocument/workspaceSymbols to use the query sent by client. 2021.02.27-23.35.55 # Add support to complete full qualified namespaces - Fixes #337 Add :log-path setting to log to a custom file. Avoid exception on code actions when on cljc reader macros - Related to #346 2021.02.26-13.58.48 # Improve clojure-lsp config search checking always home dir considering XDG_CONFIG_HOME and project root up to system root (/) - Fixes #339. Handle incremental text changes on textDocument/didChange notifications following LSP protocol, improving performance for huge files. Add clj-kondo version to --version and server-info. Add new create private function code action. 2021.02.24-14.23.08 # Improve completion performance resolving the item only when documentation is requested Add new thread first/last all code actions 2021.02.21-21.02.51 # Implement support for textDocument/signatureHelp - Fixes #324 Disable notify-references on didChange with a flag notify-references-on-change . Fix completion not working when reader macro on file - Fixes #332 2021.02.19-23.08.40 # Fix duplicated symbols for cljc files on textDocument/documentSymbols - Fixes #328 Add namespace require when completing a unimported namespace - Fixes #309 Fix completion not working for cljc files 2021.02.19-00.19.27 # Fix completion of invalid clojure core (e.g. foo/ ) - Fixes #270 2021.02.17-17.00.45 # Allow find all references across the project of simple keywords Allow specify custom sqlite.db location with sqlite-db-path , default to <project>/.lsp/sqlite.db 2021.02.14-19.46.47 # Removing false positive logs from invalid analysis from clj-kondo macro expand analysis Fix call hierarchy when the reference was not open yet in the editor. Smart re-analyze variable/function references when arguments of the definition were updated. Rollback Macos native image compress until it works for MacOS Big Sur - #322 2021.02.13-18.04.19 # Bump clj-kondo to fix false-positive unresolved-vars Prioritize project analysis on all analysis during find definition - Fixes #318 Compress native binaries with UPX decreasing binary size. 2021.02.12-03.13.12 # Fix completion issues with graalvm native linux binaries when completing local variables. Fix completion exception when completing numbers - Fixes #310 Completion inside a require suggests all available namespaces Change log pattern to /tmp/clojure-lsp.<TIMESTAMP>.out use default temp file. Should fix issues with permissions on tmp folder. 2021.02.11-12.43.06 # Fix auto add ns not working for projects. New code action: Move to let New code action: Change coll to map, list, set or vector 2021.02.10-03.01.19 # Fix config passed to clj-kondo during analysis - Fixes #308 2021.02.09-18.28.06 # Fix auto add ns to check project root and source paths Add alias on copmletion items - Fix completion items for Calva client 2021.02.07-22.51.26 # Fix install-latest-clojure-lsp.sh script - #304 Fix clojure-lsp re-analysing classpath when project contains a keyword starting with a number - #305 Allow clj-kondo to pick up config correctly in mono repos - #303 2021.02.07-03.04.31 # Make release's native binaries executable by default - #299 Improve completion removing the necessity to call completion/resolveItem - #292 New code action: Add suggested alias to namespaces - #302 2021.02.05-03.05.34 # Add support for keyword analysis (definition, references, completion, rename, hover) Reduce jar and binaries size excluding some dependencies (Need to fix a lein issue yet) 2021.02.04-02.08.58 # Fix --version on graalvm native compiled binaries 2021.02.04-01.09.21 # Add integration tests to release process 2021.02.02-14.02.23 # Fix clojure-lsp embedded jar binary during release CI Fix duplicate references on cljc files 2021.02.02-03.06.46 # Add clojure.java.io to known requires - #291 Add manual System/gc after first classpath scan, it should decrease memory after the first startup Add support for Windows GraalVM compiled native binary 2021.02.01-20.37.52 # Add native binaries for Linux and MacOS compiled with GraalVM #267 (Experimental) 2021.01.28-03.03.16 # Fix clj-kondo batch analysis when merging batchs - Fix #284 2021.01.27-21.47.42 # Fix missing printlng and avoid errors for next time (this was causing issues in clients like vim coc) 2021.01.26-22.35.27 # Fix document-symbol after #261 - Fixes #276 Reduce memory usage on startup batch analyzing classpath via clj-kondo. - Fixes #268 2021.01.25-22.56.05 # Do not remove document on textDocument/didClose , related to #264. Fix default project-specs for shadow-cljs to use npx prefix. Fix range of textDocument/hover for definition usages. Fix completionItem/resolve broken after #261. 2021.01.25-17.22.05 # Remove references code-lens from deftest forms Fix completion for alias ns from external deps - Fixes #269 2021.01.22-13.04.28 # Huge refactor https://github.com/clojure-lsp/clojure-lsp/pull/261 which uses clj-kondo analysis / findings output to almost all clojure-lsp features. Should significantly increase performance and startup time Should fix almost all bugs/issues with windows Users since we now rely on clj-kondo analysis Remove all lint configs from clojure-lsp including macro-defs , they should be configured on clj-kondo side now via .clj-kondo/config.edn Move file path on documentation to bottom 2021.01.20-01.39.32 # Fixes args for extract-function refactoring - Fixes #263 2021.01.16-03.28.20 # Check for defintions when finding references with includeDeclaration as true - Fixes #260 Add custom command cursor-info to debugging clojure-lsp. Fix unnecessary new-lines on imports when executing clean-ns 2021.01.14-23.15.54 # Check for the whole line to add-miising-* code actions instead of expect the cursor at the ns to be required/imported - Fixes #258 Return all possible add-missing-* code actions to the same line. 2021.01.14-17.19.10 # Fix add missing import code actions after refactor 2021.01.14-12.44.42 # Fixes #208 2021.01.14-02.30.28 # LSP 3.16: Add support for codeAction/resolve improving performance if client supports it Bump extend lib [CI] Remove auto release, next releases should contain more than one PR/fix","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"General Improve settings documentation. Fix completion performance regression from previous release. Consider .bb and .cljd files on watched file changes. #906 Bump to clojure 1.11.0 Improve analysis query performance as a whole for lots of features. #916 Bump clj-kondo to 2022.04.08 fixing semantic tokens for :require , :refer and :as . #1609 Move lsp4clj to outside clojure-lsp to its own repo/jar release. Fix local files outside source-paths not being linted even if opened/changed. Consider filename + lastModified as checksum for external files, avoiding analyzing it if analysis is already present. graalvm: Compile static linux with --musl for better compatibility. #868 Editor Introduce ALPHA move-form command. #566 Rename \"Move coll entry up/down\" to \"Drag forward/backward\", matching Calva/Paredit terminology drag: clauses move intuitively in clojure.test/are drag: top-level forms can be dragged #891 Improve completion performance for most cases, reducing time to compute clj/cljs core symbols. completion: suggest functions defined in Clojure 1.10 and 1.11 completion: Fix to no require extra ns when alias is already required. #920","title":"Unreleased"},{"location":"CHANGELOG/#20220331-200020","text":"Fix URI resolver on java JDK logic. Fix zipfile scheme when finding external deps.","title":"2022.03.31-20.00.20"},{"location":"CHANGELOG/#20220331-142114","text":"Add java class find-definition support, decompiling .class files when available. #762 Add JDK source discoverability feature, searching for installed JDK for later analyze with clj-kondo and support java classes interop. Add :java :download-jdk-source? setting to download JDK source after startup if not cached before globally or found locally. Disabled by default. Avoid high CPU usage and freezes by more efficiently finding referenced files to notify on file change. #844 @mainej Bump clj-kondo to 2022.03.10-20220331.135739-32 improving java analysis and fixing a critical regression for re-frame. #888 This release was supported by Clojurists Together","title":"2022.03.31-14.21.14"},{"location":"CHANGELOG/#20220326-184708","text":"Fix unused-public-var not considering excluding comments, changing async-custom-lint? setting to false.","title":"2022.03.26-18.47.08"},{"location":"CHANGELOG/#20220325-120259","text":"General Fix cljfmt settings merge during refresh/classpath configs merge to avoid multiple config vectors on same symbol. Fix install script for aarch64. #794 Fix handling cljfmt config files that end in .clj https://github.com/weavejester/cljfmt/issues/190 parser: more efficiently seek to cursor position, improving performance especially in large files. #793 @mainej Fix clean-ns not sorting properly node requires for cljs. #815 Fix move-to-let to ensure locals don't move out of scope. #830 Improve logic around require suggestions. #837 Enhance move-to-let to introduce and expand let if an existing one doesn't exist. #829 Bump org.clojure/clojure to 1.11.0 . Fix move-coll-entry to maintain cursor position instead of a range. #862 Clean ns automatically after adding missing require/imports, enabled by default under new :clean :after-ns-refactor flag. #558 Editor extract-function: Fix wrong args when extracting from multi-arity fn. #683 extract-function: Fix wrong args when extracting after a local usage. #812 @mainej move-coll-entry: clauses move intuitively in assoc , case , cond , and similar functions. #780 @mainej move-coll-entry: fix NPE when when invoked from top-level #803 @mainej Generate stubs async after startup, improving startup time. #788 Improve and add lots of new snippets following practicalli config. #797 Improve how watched new files are analyzed avoiding infinite loops and performance issues. #796 Avoid infinite loops when several files are changed simultaneously. #796 @mainej Fix \"incoming call hierarchy\" not considering usages inside defmethods. #808 range-formatting: more efficiently locate extent of range and reduce number of calls to cljfmt, improving performance especially when formatting large ranges. #795 @mainej cycle-fn-literal: new feature convert between function-literal syntaxes (fn [] ...) <-> #(...) . #774 Add find-implementation feature to defmulti and defmethod . #751 Make find-implementation of defprotocol names find its implementations and find-implementation on deftype / defrecord methods find other implementations. Add new code action Introduce let for existing command. #825 Make find-implementations consider reify . #827 Fix namespace on file creation when nested source-paths are available. #832 unused-public-var: fix to show warnings on vars defined with declare. #840 unused-public-var: large performance improvements, especially for large projects. #861 @mainej API/CLI Extract lsp4clj as a seperate library. #807 @Cyrik Supported by Scarlet Fix inconsistency with clean-ns/format not copying kondo configs. This release was supported by Clojurists Together","title":"2022.03.25-12.02.59"},{"location":"CHANGELOG/#20220223-121212","text":"General Use :source-aliases setting during default deps.edn and lein project-spec aliases, avoiding the need to configure a whole project-spec just because of a additional alias. Exclude from unused-public-var linter vars with metadata ^:export . #753 Fix clean-ns multiple refers sort when there is a alias before the refers. Bump clj-kondo from 2022.01.15 to 2022.02.09 adding support for implementation analysis and more improvements. Medium performance improvement during startup when unused-public-var linter is disabled. Medium performance improvement during startup on unused-public-var calculation parallelizing calculations. Small performance improvement on code actions calcullation. Add :use-source-paths-from-classpath setting defaulting to true, which makes clojure-lsp do not manually discovery source-paths but get from classpath excluding jar files and paths outside project-root. #752 #551 Improve completion performance when all clojure.core or cljs.core symbols are valid completions. #764, #771 @mainej Fix scenarios where the lint findings in individual files differed from what you'd expect based on the .clj-kondo/config.edn settings. Add :exclude-regex and :exclude-when-definted-by-regex to :clojure-lsp/unused-public-var linter. Bump org.clojure/clojure to 1.11.0-rc1 . Editor Fix exception during code actions calculation when in a invalid code of a map with not even key-pairs. Don't return diagnostics for external files like files on jar dependencies, avoiding noise on lint when opening dependencies. Support finding implementations of defprotocol and references of defrecord/deftype, implementing LSP method textDocument/implementation . #656 Make the actions and commands aware of when they were invoked from comments or whitespace. This will allow individual refactorings to be more deliberate about how they handle comments and whitespace. #716 @mainej Correctly position the cursor after calling move-coll-entry-down on an entry with leading comments. #758 @mainej Don't return completions when invoked from a comment, avoiding performance problems. #756 Fix small anomalies in parameter names of extracted private functions. #759 @mainej Add semantic tokens for protocol implementations methods like defrecord and deftype. Small performance improvevement on code lens calculation using transducers. API/CLI Small performance improvement to format , clean-ns , diagnostics , and rename via parallelizing parts of the logic. Fix edn->json parser of serverInfo/raw for Calva use cljfmt configuration. #763 Add :cljfmt-raw config to serverInfo/raw for Calva. #768 Add support for passing specific --filenames for most actions. #775 This release was supported by Clojurists Together","title":"2022.02.23-12.12.12"},{"location":"CHANGELOG/#20220201-200232","text":"General Fix classpath hash regression introduced by last release","title":"2022.02.01-20.02.32"},{"location":"CHANGELOG/#20220201-165314","text":"General Migrate project from depstar -> tools.build. #711 Improve classpath hash to consider invaliding cache when local root deps was changed. Replace datalevin cache db with transit. #703 Bump Graalvm from 21.3.0 to 22.0.0.2 improving binary performance/size Update XDG_CONFIG_HOME to clojure-lsp directory in doc/settings.md Editor Support going to namespace definition on an alias. #706 Add LSP textDocument/declaration , for now adding the making possible navigate to alias and namespaces declared on the namespace. #680 Fix removal of file analysis on didClose for external files like jars. #717 Fix cursor not moving when using code actions that move the cursor automatically. Fix additional-snippets to work on top-level forms as well. Fix resolve completion item not returning insertText. #719 @Cyrik Remove support for LSP codeAction/resolve . It added complexity and was not used in a way that improved performance of the action menu. #722, #725, #726 Fix create public function refactoring not working when function is not a function call.","title":"2022.02.01-16.53.14"},{"location":"CHANGELOG/#20220122-013109","text":"General Fix freezing in some cases during clojure-lsp startup linting. #708","title":"2022.01.22-01.31.09"},{"location":"CHANGELOG/#20220120-141243","text":"General Bump clj-kondo to 2022.01.15 . Add :classpath to serverInfo command for downstream usages. Fix issues in extract-function that arise when operating over .cljc files. Add setting :copy-kondo-configs? to allow disable auto clj-kondo config copy, enabled by default. #694 Lint unused public keywords, like unused re-frame events/subs. #691 Fix rename of namespaced keywords -> aliased keywords. #665 Huge refactor on clojure-lsp codebase, spliting code into submodules, this made possible remove a lot of deps from API jar and help separate clojure-lsp features in the future. #658 Send testTree notification for all project test files after clojure-lsp start. #697 Editor Improve 'create function' refactor code action handling multiple cases. #682 Fix 'resolve macro as ...' code action not working. Fix showDocumentRequest issues when triggered via some refactor code action. Add new code actions + commands Move coll entry down and Move coll entry up to move entries within collections. #684, #701 API/CLI Make format , clean-ns and rename features not need to scan whole classpath, analyzing only project code improving performance a lot.","title":"2022.01.20-14.12.43"},{"location":"CHANGELOG/#20220103-194610","text":"Catch clj-kondo prints to stdout and log to clojure-lsp log file avoiding crashes on some clients like vscode/Calva.","title":"2022.01.03-19.46.10"},{"location":"CHANGELOG/#20220103-154119","text":"General Fix some analysis conflicts regarding custom-async-lint? feature introduced on latest release causing outdated analysis and some deadlocks. Editor Fix inline symbol code action regression from previous releases. #678 Fix expand let refactor duplicating variables in some cases. #676 Add completion support to potemkin usages of a namespace. API/CLI Wait for db cache upsert before end proccess, avoiding the need to re-lint whole classpath on next api/cli runs. Fix the need to use :raw? true on babashka pod usage.","title":"2022.01.03-15.41.19"},{"location":"CHANGELOG/#20211220-003656","text":"General Bump clj-kondo to 2021.12.19 , supporting auto-load configs, improving potemkin support, adding more linters and more. Merge :cljfmt settings with :cljfmt-config-path if file path exists. Avoid high CPU and lockup when clj-kondo throws exceptions. #671 Allow absolute paths in deps.edn :local/root #672 Fix clojure-lsp not loading for some mono-repo cases, improving local/root support for polylith projects. #673 Avoid infinite loop because of cyclic dependencies on deps source-path discovery. Add babashka pod. #555 Editor Change call hierarchy to return selection range of usage, not function definition. Return edits in codeAction/resolve responses rather than commands . #655 Improve :linters :clj-kondo :async-custom-lint? to avoid infinite loops and default to true . Add new custom LSP feature Test Tree , which shows all test hierarchy of a file. #653 Improve function name finding to consider other function definition types for some features. #666 Make textDocument/hover return the correct range from LSP spec, the element range instead of the element scope range. API/CLI Exit process if any error during classpath lookup. Opt-out via :api :exit-on-errors? flag.","title":"2021.12.20-00.36.56"},{"location":"CHANGELOG/#20211201-122816","text":"General Add support for LSP method textDocument/prepareRename which it's the proper way to check if the rename will work correctly. #642 Expose new custom method clojure/cursorInfo/raw for custom hack on current cursor information code. #645 Support stub generation using clj-easy/stub , adding analysis and linting support for closed sources codes like Datomic. Check :stubs settings for more details. #637 Handle config deep merge differently for collections, concating instead of overwriting. Fix unnecessary exception thrown on graal images during startup. Support deps.edn :local/root source-paths discovery, improving support for monorepo projects like polylith . #652 New setting value for :clean :sort :require : :lexicographic . #654 Bump clj-kondo to 2021.10.20-20211126.151305-16 . Editor Support completion on aliased keywords. #649 Add new Sort map keys refactoring code action. #651 Add new Create function code action, allowing to create a function on a existing namespace or creating a new namespace + the function. #646 Improve Extract function refactoring to consider comments above current function. Experimental: new :linters :clj-kondo :async-custom-lint? setting, when true, scan unused-public-vars async improving lint/analysis UI feedback for huge buffers (> ~1000 lines). Default false . This release was supported by Clojurists Together","title":"2021.12.01-12.28.16"},{"location":"CHANGELOG/#20211116-165214","text":"General Improve rename feature to not heavily rely on valid source-paths for most cases. Fix setTrace exception logs for graalvm native images. Huge improvements on namespaces renames and namespaces references find. #573 Fix/Remove warnings during datalevin access. Improve freezing for some MacOS cases. #631 Bump clj-kondo to 2021.10.20-20211116.110002-7 improving code parsing and other fixes. Editor Fix \"Add require\" code actions adding multiple requires instead of the selected. Improve \"Add require\" wording, making it easier to understand what each different action will do. Smart check all available refers to require, adding refer options to Add require code actions. #627 Big improvements on keyword completions. #630 Add setting keep-parens-when-threading? to keep parens for single arity functions when threading. #636 Avoid adding duplicate requires when adding a new require via code action. #640 Improve common known snippets to replace completion items, improving completion UX. #638 This release was supported by Clojurists Together","title":"2021.11.16-16.52.14"},{"location":"CHANGELOG/#20211102-152447","text":"General Bump Graalvm from 21.2.0 to 21.3.0 improving binary performance/size Fix wrong parse of code when code contains namespaced maps like #:foo{:bar 1} . This issue was affecting a lot of features for example code actions. Bump datalevin from 0.5.26 to 0.5.27. Improve semantic tokens for dynamic vars, function definitions, namespaced and aliased keywords. Fix bug where :source-paths settings could be hot-reloaded with wrong-value. Editor Deprecates setting :show-docs-arity-on-same-line? in favor of :hover :arity-on-same-line? . Add support to new LSP LinkedEditingRange feature. #341 Improve suggested Add require ... code actions, this should make clojure-lsp smarter when user wants to add a missing require. #614 Change :notify-references-on-file-change default from false to true , we had some performance improvements and I've been testing this for some time now and didn't see any new issues with that. This should improve a lot the UX when user change any code that is references on other files, updating the diagnostics for those files as well. Improve rename feature UX to output errors when it's not possible rename. Add support for window/showDocument LSP method, used on create-test command/code action after creating the test to show the test file. Add new Unwind thread once and Unwind whole thread code actions to undo a thread call. Improve code actions performance requesting async all actions. Add new LSP custom method clojure/clojuredocs/raw which takes a symbol and a namespace (both strings) and returns any Clojuredocs entry found, otherwise null . Fix missing keywords rename/references for destructured keywords. CLI Show error/warning message when a classpath scan fail during analysis. Fixes #626 Add coloring to diagnostics output matching diagnostic severity. This release was supported by Clojurists Together","title":"2021.11.02-15.24.47"},{"location":"CHANGELOG/#20211020-164947","text":"Editor Hot fix clojuredocs on graalvm native image. Bump clj-kondo to 2021.10.20-20211020.123254-3 to fix a specific issue with cljs. Implement support to return to client LSP Errors, making user UX better since clojure-lsp can return specific errors for specific exceptions.","title":"2021.10.20-16.49.47"},{"location":"CHANGELOG/#20211020-130411","text":"General Improve intialization feedback report messages. Consider dev and test alias for deps.edn projects as project-specs during classpath lookup. #586 Avoid scanning source-paths twice, as it was being considered as part of external classpath as well. Change cache db from sqlite to datalevin for faster startup + better graalvm compatibility. Make the cache analysis save async to make startup faster. Support Auto refresh settings memoizing with a ttl of 1 second avoiding the need of restarting server when changing configs. #502 Bump clj-kondo adding new gen-class linter and other fixes/improvements. Fixes #589 Remove unused duplicate require if any. #527 Fix crash on clean-ns when ns contains comments. Improve project analysis filter to check source-paths. #597 Editor Add reference code lens for ns forms. #578 Fix expand-let bug that occurs when a list form precedes let. #590 Add new command to create test for function at point. #582 Add new code action to create test for current function/var Add private to documentSymbol to make clear that a var or function is private . Add new code action Suppress xxx diagnostic , adding clj-kondo comment code to ignore the diagnostic. #591 Add more semantic tokens: aliases for macros, variable and function definitions. Add clojuredocs information during symbol hover. #571 This release was supported by Clojurists Together","title":"2021.10.20-13.04.11"},{"location":"CHANGELOG/#20210930-152801","text":"Editor Hot fix hover content wrong type hinting.","title":"2021.09.30-15.28.01"},{"location":"CHANGELOG/#20210930-122816","text":"General Use lower-case for refer/import/require sorting. #560 #561 Avoid removing comments when sorting/cleaning namespace. #559 Break lines when sorting refers along with then new :clean :sort :refer :max-line-length setting with a default of 80 . #562 Deprecate lens-segregate-test-references in favor to :code-lens :segregate-test-references Check for a default .cljfmt.edn config file for cljfmt config settings if no :cljfmt-config-path was provided. #563 Bump clj-kondo to 2021.09.25 fixing false-positives with potemkin import-var analysis. Re-scan whole project if any clj-kondo config changed for better consistence. #331 Fix clojure-lsp not initializing when empty project.clj . #579 Support finding config in classpath via new setting :classpath-config-paths [\"my-org/my-lib\"] . #580 Editor Fix resolve macro as code action after regression introduced recently. Fix unused-public-var not being suppressed during project startup. #554 Improve hover feature to return elements when inside a function call. #569 Fix create-private-function command and code action to consider when new function is inside thread macros. Support $/progress LSP feature, sending notifications for client when server is starting, improving the feedback for the user. Improve semantic tokens support for java classes and methods. API/CLI Support renaming namespaces as well with rename feature. Use relative paths instead of absolute paths on diff messages. Add analyze-project! to analyze whole project only and cache analysis, useful for REPL usage for example. Follow same exit status from clj-kondo for diagnostics feature. #572 Improve start project feedback reporting the percentage and specific message. This release was supported by Clojurists Together","title":"2021.09.30-12.28.16"},{"location":"CHANGELOG/#20210913-222535","text":"Editor Rollback change on didChangeWatchedFiles for :change events, avoiding outdated changes overwriting newer changes.","title":"2021.09.13-22.25.35"},{"location":"CHANGELOG/#20210913-193200","text":"General Create .clj-kondo folder if not exists in project root. #528 Fix exception when :clojure-lsp/unused-public-var linter is :off . #546 Bump clj-kondo to 2021.08.07-20210903.210340-28 to fix a false-positive with potemkin. https://github.com/clj-kondo/clj-kondo/issues/1370. Bump clj-kondo to 2021.08.07-20210909.131804-29 fixing issues with built-in clj-kondo cache not present on graalvm binaries. #548 Exclude cljs.test/deftest from unused public vars linter. Migrate default db file from .lsp/sqlite.db to .lsp/.cache/sqlite.db , this is necessary as in the future we will replace sqlite with other db implementation, for users they just need to consider/gitignore the .lsp/.cache folder, this way any next change on db implementations or any other cache will not affect user. Auto migrate existing .lsp/sqlite.db to new .lsp/.cache/sqlite.db to avoid unnecessary project re-scan. Deprecates :sqlite-db-path in place of :cache-path . Editor Fix didChangeWatchedFiles to correctly create the file on server, properly change file content and re-scan with clj-kondo, or remove file analysis. This should improve LSP analysis reliability when changing files outside the editor. #536 Improve completion only showing valid local vars for current cursor. Improve completion sorting adding priority to each item, showing most used symbols like variables and functions first before other completion items. API/CLI New diagnostics command, which return all diagnostics found by clojure-lsp (using clj-kondo). Check the API section for more details. This release was supported by Clojurists Together","title":"2021.09.13-19.32.00"},{"location":"CHANGELOG/#20210904-171144","text":"Hotfix java classes not present on jar, required for clojure-lsp downstreams.","title":"2021.09.04-17.11.44"},{"location":"CHANGELOG/#20210903-004246","text":"General Improve logging during startup for better troubleshooting. Refactor allowing calls to clojure-lsp.main/run! for manually passing args, useful for lein-clojure-lsp for example. Internal: Move graalvm configuration to sqlite-jdbc. Recognize deftest as function definition form for refactoring features like extract-function . Bump Graalvm from 21.1.0 to 21.2.0 API/CLI Use clj-kondo custom lint for API as well, required for correct diagnostics API feature. Editor Fix regression, custom source-paths from initializationOptions were not being parsed correctly. #537 Documentation New domain for documentation and webpage https://clojure-lsp.io","title":"2021.09.03-00.42.46"},{"location":"CHANGELOG/#20210824-144156","text":"General Fix classpath scan when classpath has other things like new lines or warning message besides the classpath. Fixes #523 Improve clean-ns to remove empty reader conditionals( #?(:clj) or #?@(:clj []) on ns form) after cleaning requires/imports. Fix clean-ns false-positives removals to cljc files when the alias/refer/import is being used inside a reader conditional. Add new setting :linters :clj-kondo :ns-exclude-regex which allows exclude diagnostics/findings for namespaces matching that regex. Fix merge of configs resolved for projects with multiple configurations in parent folders and subprojects. Docs Improved the settings docs with a new link to a file with all available clojure-lsp settings.","title":"2021.08.24-14.41.56"},{"location":"CHANGELOG/#20210816-190230","text":"Fix clojure-lsp --version","title":"2021.08.16-19.02.30"},{"location":"CHANGELOG/#20210816-144754","text":"General Fix wrong parse of source-paths for bb.edn when :paths contains symbols not only strings. #507 Bump clj-kondo to fix a issue with clojure-lsp running in a lein process. Editor Fix find-definition in jars for cljc files where the var is available on both cljs and clj files. #509 Add clojure.core.async common vars to common-refers to be required via code action. Remove diagnostics when files are deleted, properly cleaning server. #513 Don't add ns form to blank edn files. #515 Fix initializationOptions parsing for some clients. #516 Fix refactor 'add missing refer' when there is already that namespace with a alias but no refers. Improve :notify-references-on-file-change performance and use-cases, still disabled by default for some time. API Rollback printing only via CLI to work with API as well. (can be disabled via :raw? option) Support for release of lein-clojure-lsp","title":"2021.08.16-14.47.54"},{"location":"CHANGELOG/#20210805-193609","text":"Bump clj-kondo to fix window path issues with analysis. Fix issue with references code lens for vim.","title":"2021.08.05-19.36.09"},{"location":"CHANGELOG/#20210805-182554","text":"Fix async project lint after startup for huge projects. #506 Fix :lint-project-files-after-startup? to be considered before clojure-lsp lint unusued public vars. Fix excluded symbols for code lens, making clojure-lsp check clj-kondo config as well for the :clojure-lsp/unused-public-var excludes","title":"2021.08.05-18.25.54"},{"location":"CHANGELOG/#20210803-133303","text":"General Parse correctly unescaped URIs sent from clients like vim avoiding errors on some features. Bump clj-kondo fixing analysis position issue with declare , making rename and other features work. Don't use PowerShell profiles on Windows when analyzing classpath. Fixes https://github.com/BetterThanTomorrow/calva/issues/1050 Support babashka classpath and source-paths discovery via bb.edn file. (needs babashka >= 0.5.1) Editor Add :hover :hide-file-location? settings option to disable displaying the source path on hover. Use new clj-kondo :custom-lint-fn for the :unused-public-var , this should improve performance and give the ability to suppress unused vars via code with #_{:clj-kondo/ignore [:clojure-lsp/unused-public-var]} or #_:clj-kondo/ignore","title":"2021.08.03-13.33.03"},{"location":"CHANGELOG/#20210728-142406","text":"General Minor fix on the analysis queries comparison. Improve GraalVM configuration to use direct/less configurations. Bump clj-kondo 2021.06.18 -> 2021.07.28 which adds support for macroexpanding. Editor Fix outgoing/incoming call hierarchy when vars are outside project/external jars. Fix completion of aliases without var names typed yet, for example: string/ API/CLI Fix filename in diffs with dry option. Add coloring to diffs following git diff. Add ns-exclude-regex for commands that check whole project, allowing to exclude certain namespaces via regex.","title":"2021.07.28-14.24.06"},{"location":"CHANGELOG/#20210719-144652","text":"General clean-ns now sorts ns children forms according to the ClojureStyleGuide, at the moment moving require form before import form, enabled by default under flag :clean :sort :ns setting. Improve startup error handler and logging during project analysis. Related to #484 Performance improvements using transducers on analysis queries. Fixed auto-resolve source-paths for lein projects that get source-paths dynamically, clojure-lsp will use the default source-paths for these cases Editor Improve hover output, both markdown and plain text forms. Allow calling thread-first/last and thread-first-all/last-all from within the list. Improve resolve-macro-as messages and default excluded symbols. API/CLI Fix empty XDG_CONFIG_HOME not defaulting to $HOME/.config #474 Improve verbose logging setting.","title":"2021.07.19-14.46.52"},{"location":"CHANGELOG/#20210712-123059","text":"Editor Make semantic-tokens return no token for unknown symbols which has :clj-kondo/unknown-namespace on its analysis. Fix file uri location when hovering a symbol. Add reference code lens to keyword definitions, e.g. re-frame.core/reg-sub . Add semantic-tokens debug information to cursor-info response. API/CLI Fix when ns form does not match filename. #466 Fix errors with project-root on graalvm binary Improve API usage avoiding exceptions and returning just data instead. Improve analysis cache to multiple API calls. Add new --raw option allowing to display only raw data. Useful to integrate with other tools like reviewdog.","title":"2021.07.12-12.30.59"},{"location":"CHANGELOG/#20210705-203112","text":"API/CLI Add --verbose option for debugging purposes. Fix usage as library parsing :exec-args correctly","title":"2021.07.05-20.31.12"},{"location":"CHANGELOG/#20210705-151214","text":"General Add :clean :sort settings option to disable sorting during clean-ns . Add :keep value to :ns-indent-blocks-indentation setting to don't change indentation during clean-ns . Deprecate install-latest-clojure-lsp.sh in place of install new script. Improve source paths discoverability for leiningen projects following the same rules as deps.edn projects. For more information, check the settings section . API/CLI Add --dry option to commands, useful to print only diffs instead of making changes. Check the new setup-clojure-lsp Github Action to run clojure-lsp on CI. Add format feature using cljfmt. Now, every release is available in clojars as com.github.clojure-lsp/clojure-lsp .","title":"2021.07.05-15.12.14"},{"location":"CHANGELOG/#20210701-194902","text":"Fix --project-path option for API. Add --log-path option to API.","title":"2021.07.01-19.49.02"},{"location":"CHANGELOG/#20210701-134618","text":"Fix find-references and references lens for defrecord . Improve clean-ns refactoring following the Clojure style guide. Fix clean-ns corner case issue where it would replace the :as value with the :refer value. Deprecate :keep-require-at-start? in favor of :clean :ns-inner-blocks-indentation with default value of :next-line . Bump org.xerial/sqlite-jdbc from 3.34.0 to 3.36.0. Avoid adding duplicated namespace for new blank files. Add API / CLI support, form more information check the API section.","title":"2021.07.01-13.46.18"},{"location":"CHANGELOG/#20210624-142411","text":"Fix missing LSP 3.16 graalvm reflection configs. #452","title":"2021.06.24-14.24.11"},{"location":"CHANGELOG/#20210624-012001","text":"Fix graalvm reflect config for LSP 3.16 protocol. #449 Use last definition when showing signature help. #446 Create 2 new LSP custom methods: clojure/serverInfo/raw and clojure/serverInfo/log deprecating old commands server-info and cursor-info , check the documentation for more information. Add :final-settings to serverInfo methods. #450","title":"2021.06.24-01.20.01"},{"location":"CHANGELOG/#20210621-143054","text":"Avoid removing whole require if unused refer but with used alias during clean-ns. #447 Bump cljfmt 0.7.0 -> 0.8.0. Fixes #266 Bump clj-kondo 2021.06.01 -> 2021.06.18","title":"2021.06.21-14.30.54"},{"location":"CHANGELOG/#20210614-170047","text":"Improve source paths discoverability for deps.edn projects. Adds :source-aliases for customization. For more information, check the settings section .","title":"2021.06.14-17.00.47"},{"location":"CHANGELOG/#20210601-161944","text":"Fix graalvm issue on completionItem InsertTextMode Bump clj-kondo and rewrite-clj to latest releases.","title":"2021.06.01-16.19.44"},{"location":"CHANGELOG/#20210527-174234","text":"Fix corner case error with project paths with spaces or other special characters. #437 Drastically improve didOpen performance, improving kondo findings parsing and making linting async avoiding blocking some editors. #435 Fix :auto-add-ns-to-new-files? flag always being considered as true . #436","title":"2021.05.27-17.42.34"},{"location":"CHANGELOG/#20210522-165045","text":"Fix completion item kind of clojure core items. Fixes #426 Fix graalvm reflect config for SublimeText - #430 Improve code lens for segregated code lens when on test files.","title":"2021.05.22-16.50.45"},{"location":"CHANGELOG/#20210514-152602","text":"Include non full qualified vars on unused-public-var exclude filter. Improve hover documentation: use correct markdown for docstrings; remove unnecessary new lines; add link to filename location. Rollback full text changes on last release and change approach for a temporary fix. #424","title":"2021.05.14-15.26.02"},{"location":"CHANGELOG/#20210506-194400","text":"Quick fix full text changes to handle it sync for semantic tokens Segregate main references from test references with option to disable via lens-segregate-test-references","title":"2021.05.06-19.44.00"},{"location":"CHANGELOG/#20210427-201745","text":"Significantly improve the performance of workspace symbol filtering/searching. See relevant commit . Always sort refers when clean-ns. Add support for installing with homebrew on Linux. Bump clj-kondo to 2021.04.24-20210426.144134-2 adding support for finding re-frame by keyword. Fixes #411 Fix find definition going to declare - Fixes #340 Remove common already known clojure macros from Resolve macro as code action.","title":"2021.04.27-20.17.45"},{"location":"CHANGELOG/#20210423-154947","text":"Improve resolve-macro-as command to check and log if couldn't resolve the macro. Improve workspace symbol filtering/searching. Now, the sole candidates shown are guaranteed to include all the characters contained in the filter/search string. Add more tokens to semantic tokens: keywords, functions/var usages, java classes, local variables. Bump Graalvm from 21.0.0 to 21.1.0 Bump clj-kondo to 2021.04.23 fixing some keywords corner cases.","title":"2021.04.23-15.49.47"},{"location":"CHANGELOG/#20210413-124733","text":"Add common snippets on completion. Check all available snippets here . Add support for custom snippets via :additional-snippets . Check here for more information. - Fixes #403 Bump lsp4j from 0.11.0 -> 0.12.0","title":"2021.04.13-12.47.33"},{"location":"CHANGELOG/#20210407-163410","text":"Fix renaming keywords in cljc files producing duplicate edits. After project startup, publish all project only diagnostics. This is a approach done by other LSPs to make work features like Project errors . Feature flag via lint-project-files-after-startup? with default true . Add experimental support for aarch64 linux native binary Fix formatting issues with a regression introduced on a previous release. - Fixes #339 and #396","title":"2021.04.07-16.34.10"},{"location":"CHANGELOG/#20210403-184355","text":"Fix textDocument/workspaceSymbols filter not working on native binaries. Report duplicate linters as default, can be disabled via :linters :clj-kondo :report-duplicates - Fixes #390 Bump rewrite-clj to 1.0.605-alpha to fix exceptions when on clojure files with babashka interpreter on first line. Bump clj-kondo 2021.04.01-20210402.215253-6 to fix bug https://github.com/clj-kondo/clj-kondo/issues/1246","title":"2021.04.03-18.43.55"},{"location":"CHANGELOG/#20210330-204234","text":"Bump clj-londo 2021.03.22-20210327.192113-4 - Fixes #385 Add support for outgoing call hierarchy - Fixes #384 Improve and fix missing completion item kinds.","title":"2021.03.30-20.42.34"},{"location":"CHANGELOG/#20210326-234107","text":"Bump clj-kondo 2021.03.22-20210324.110254-3 - Fixes #382 [graalvm] Fixes Unable to invoke no-args constructor for class org.eclipse.lsp4j.ShowDocumentCapabilities error. Fix/enhance keyword rename - #383","title":"2021.03.26-23.41.07"},{"location":"CHANGELOG/#20210324-004155","text":"Migrate from lein to deps.edn Bump clj-kondo to 2021.03.22 Fix clean-ns sorting according to symbols not brackets - Fixes #380 Fix missing graalvm reflect config for CompletionItemTextEdit - Fixes #381","title":"2021.03.24-00.41.55"},{"location":"CHANGELOG/#20210321-232919","text":"Add code action 'resolve macro as', it requires client to fill the chosen macro and clj-kondo config file. Bump rewrite-clj to 1.0.594-alpha Bump data.json to 2.0.1 Bump lsp4j to 0.11.0","title":"2021.03.21-23.29.19"},{"location":"CHANGELOG/#20210318-192341","text":"Add support for diagnostic tags: deprecated and unnecessary. Fix wrong textDocument/documentHighlight for function local-usages. Use new clj-kondo copy-configs flag to copy hooks during lint. Bunp clj-kondo to fix unused public linter check for :exclude-when-defined-by","title":"2021.03.18-19.23.41"},{"location":"CHANGELOG/#20210316-202806","text":"Fix server not analyzing after a wrong code on cljs files - #367 Rollback incremental didChange adding a new :text-document-sync-kind setting with :full as default.","title":"2021.03.16-20.28.06"},{"location":"CHANGELOG/#20210314-232246","text":"Fix completion inside refers, re-add support for it - Fixes #364 Change range of expression functions clj-kondo diagnostics to avoid collision with function signature.","title":"2021.03.14-23.22.46"},{"location":"CHANGELOG/#20210306-170535","text":"Fix incremental didChange, debouncing distincting by uri, fixing some inconsistent file changes when multiple files are changed at same time (rename, iedit, etc). Make unused-public-var ignore -main public functions. Add :exclude-when-defined-by option to unused-public-var linter, check settings documentation for more information.","title":"2021.03.06-17.05.35"},{"location":"CHANGELOG/#20210305-133547","text":"Fix clojure-lsp lint crash when analyzing specific macros with clj-kondo hooks. Fix didChange for Nvim client. Add new clojure-lsp linter: unused-public-var - Fixes #359 Add option to disable clj-kondo linter, check settings documentation for more details.","title":"2021.03.05-13.35.47"},{"location":"CHANGELOG/#20210301-191854","text":"Bump clj-kondo fixing issues on require form not being analyzed. Fix textDocument/workspaceSymbols to use the query sent by client.","title":"2021.03.01-19.18.54"},{"location":"CHANGELOG/#20210227-233555","text":"Add support to complete full qualified namespaces - Fixes #337 Add :log-path setting to log to a custom file. Avoid exception on code actions when on cljc reader macros - Related to #346","title":"2021.02.27-23.35.55"},{"location":"CHANGELOG/#20210226-135848","text":"Improve clojure-lsp config search checking always home dir considering XDG_CONFIG_HOME and project root up to system root (/) - Fixes #339. Handle incremental text changes on textDocument/didChange notifications following LSP protocol, improving performance for huge files. Add clj-kondo version to --version and server-info. Add new create private function code action.","title":"2021.02.26-13.58.48"},{"location":"CHANGELOG/#20210224-142308","text":"Improve completion performance resolving the item only when documentation is requested Add new thread first/last all code actions","title":"2021.02.24-14.23.08"},{"location":"CHANGELOG/#20210221-210251","text":"Implement support for textDocument/signatureHelp - Fixes #324 Disable notify-references on didChange with a flag notify-references-on-change . Fix completion not working when reader macro on file - Fixes #332","title":"2021.02.21-21.02.51"},{"location":"CHANGELOG/#20210219-230840","text":"Fix duplicated symbols for cljc files on textDocument/documentSymbols - Fixes #328 Add namespace require when completing a unimported namespace - Fixes #309 Fix completion not working for cljc files","title":"2021.02.19-23.08.40"},{"location":"CHANGELOG/#20210219-001927","text":"Fix completion of invalid clojure core (e.g. foo/ ) - Fixes #270","title":"2021.02.19-00.19.27"},{"location":"CHANGELOG/#20210217-170045","text":"Allow find all references across the project of simple keywords Allow specify custom sqlite.db location with sqlite-db-path , default to <project>/.lsp/sqlite.db","title":"2021.02.17-17.00.45"},{"location":"CHANGELOG/#20210214-194647","text":"Removing false positive logs from invalid analysis from clj-kondo macro expand analysis Fix call hierarchy when the reference was not open yet in the editor. Smart re-analyze variable/function references when arguments of the definition were updated. Rollback Macos native image compress until it works for MacOS Big Sur - #322","title":"2021.02.14-19.46.47"},{"location":"CHANGELOG/#20210213-180419","text":"Bump clj-kondo to fix false-positive unresolved-vars Prioritize project analysis on all analysis during find definition - Fixes #318 Compress native binaries with UPX decreasing binary size.","title":"2021.02.13-18.04.19"},{"location":"CHANGELOG/#20210212-031312","text":"Fix completion issues with graalvm native linux binaries when completing local variables. Fix completion exception when completing numbers - Fixes #310 Completion inside a require suggests all available namespaces Change log pattern to /tmp/clojure-lsp.<TIMESTAMP>.out use default temp file. Should fix issues with permissions on tmp folder.","title":"2021.02.12-03.13.12"},{"location":"CHANGELOG/#20210211-124306","text":"Fix auto add ns not working for projects. New code action: Move to let New code action: Change coll to map, list, set or vector","title":"2021.02.11-12.43.06"},{"location":"CHANGELOG/#20210210-030119","text":"Fix config passed to clj-kondo during analysis - Fixes #308","title":"2021.02.10-03.01.19"},{"location":"CHANGELOG/#20210209-182806","text":"Fix auto add ns to check project root and source paths Add alias on copmletion items - Fix completion items for Calva client","title":"2021.02.09-18.28.06"},{"location":"CHANGELOG/#20210207-225126","text":"Fix install-latest-clojure-lsp.sh script - #304 Fix clojure-lsp re-analysing classpath when project contains a keyword starting with a number - #305 Allow clj-kondo to pick up config correctly in mono repos - #303","title":"2021.02.07-22.51.26"},{"location":"CHANGELOG/#20210207-030431","text":"Make release's native binaries executable by default - #299 Improve completion removing the necessity to call completion/resolveItem - #292 New code action: Add suggested alias to namespaces - #302","title":"2021.02.07-03.04.31"},{"location":"CHANGELOG/#20210205-030534","text":"Add support for keyword analysis (definition, references, completion, rename, hover) Reduce jar and binaries size excluding some dependencies (Need to fix a lein issue yet)","title":"2021.02.05-03.05.34"},{"location":"CHANGELOG/#20210204-020858","text":"Fix --version on graalvm native compiled binaries","title":"2021.02.04-02.08.58"},{"location":"CHANGELOG/#20210204-010921","text":"Add integration tests to release process","title":"2021.02.04-01.09.21"},{"location":"CHANGELOG/#20210202-140223","text":"Fix clojure-lsp embedded jar binary during release CI Fix duplicate references on cljc files","title":"2021.02.02-14.02.23"},{"location":"CHANGELOG/#20210202-030646","text":"Add clojure.java.io to known requires - #291 Add manual System/gc after first classpath scan, it should decrease memory after the first startup Add support for Windows GraalVM compiled native binary","title":"2021.02.02-03.06.46"},{"location":"CHANGELOG/#20210201-203752","text":"Add native binaries for Linux and MacOS compiled with GraalVM #267 (Experimental)","title":"2021.02.01-20.37.52"},{"location":"CHANGELOG/#20210128-030316","text":"Fix clj-kondo batch analysis when merging batchs - Fix #284","title":"2021.01.28-03.03.16"},{"location":"CHANGELOG/#20210127-214742","text":"Fix missing printlng and avoid errors for next time (this was causing issues in clients like vim coc)","title":"2021.01.27-21.47.42"},{"location":"CHANGELOG/#20210126-223527","text":"Fix document-symbol after #261 - Fixes #276 Reduce memory usage on startup batch analyzing classpath via clj-kondo. - Fixes #268","title":"2021.01.26-22.35.27"},{"location":"CHANGELOG/#20210125-225605","text":"Do not remove document on textDocument/didClose , related to #264. Fix default project-specs for shadow-cljs to use npx prefix. Fix range of textDocument/hover for definition usages. Fix completionItem/resolve broken after #261.","title":"2021.01.25-22.56.05"},{"location":"CHANGELOG/#20210125-172205","text":"Remove references code-lens from deftest forms Fix completion for alias ns from external deps - Fixes #269","title":"2021.01.25-17.22.05"},{"location":"CHANGELOG/#20210122-130428","text":"Huge refactor https://github.com/clojure-lsp/clojure-lsp/pull/261 which uses clj-kondo analysis / findings output to almost all clojure-lsp features. Should significantly increase performance and startup time Should fix almost all bugs/issues with windows Users since we now rely on clj-kondo analysis Remove all lint configs from clojure-lsp including macro-defs , they should be configured on clj-kondo side now via .clj-kondo/config.edn Move file path on documentation to bottom","title":"2021.01.22-13.04.28"},{"location":"CHANGELOG/#20210120-013932","text":"Fixes args for extract-function refactoring - Fixes #263","title":"2021.01.20-01.39.32"},{"location":"CHANGELOG/#20210116-032820","text":"Check for defintions when finding references with includeDeclaration as true - Fixes #260 Add custom command cursor-info to debugging clojure-lsp. Fix unnecessary new-lines on imports when executing clean-ns","title":"2021.01.16-03.28.20"},{"location":"CHANGELOG/#20210114-231554","text":"Check for the whole line to add-miising-* code actions instead of expect the cursor at the ns to be required/imported - Fixes #258 Return all possible add-missing-* code actions to the same line.","title":"2021.01.14-23.15.54"},{"location":"CHANGELOG/#20210114-171910","text":"Fix add missing import code actions after refactor","title":"2021.01.14-17.19.10"},{"location":"CHANGELOG/#20210114-124442","text":"Fixes #208","title":"2021.01.14-12.44.42"},{"location":"CHANGELOG/#20210114-023028","text":"LSP 3.16: Add support for codeAction/resolve improving performance if client supports it Bump extend lib [CI] Remove auto release, next releases should contain more than one PR/fix","title":"2021.01.14-02.30.28"},{"location":"api/","text":"API # clojure-lsp is commonly used in a text editor, but it has its own API featuring the main features that can be used as a library or via CLI. This is a new feature and it's experimental, so things can break at any moment, so please open an issue if you find anything wrong. Usages # CLI # clojure-lsp --help should show all available commands and options. Library # The namespace clojure-lsp.api should be used as the entrypoint for all available features of the CLI and some specific for library only usage, feel free to open a issue for missing features. Below is an example using the clean-ns feature on a deps.edn project: { :aliases { :lint-ns { :replace-deps { com.github.clojure-lsp/clojure-lsp { :mvn/version \"...\" }} :exec-fn clojure-lsp.api/clean-ns! :exec-args { :dry? true }}}} CI # You can use setup-clojure-lsp GitHub action to install clojure-lsp in a CI. Remember to install your build tool, like clojure or leiningen as well in your CI according to your project to clojure-lsp be able to scan the classpath correctly. Leiningen # To run clojure-lsp from Leiningen easily, check lein-clojure-lsp plugin. Babashka pod # It's possible to load clojure-lsp as a babashka pod giving access to the clojure-lsp.api namespace, Check babashka pod registry example . Settings # clojure-lsp will check for .lsp/config.edn in the project or home dir, but it's possible to force override the settings via the :settings option of the API or --settings option of the CLI. For all available settings, check the settings section documentation .","title":"API"},{"location":"api/#api","text":"clojure-lsp is commonly used in a text editor, but it has its own API featuring the main features that can be used as a library or via CLI. This is a new feature and it's experimental, so things can break at any moment, so please open an issue if you find anything wrong.","title":"API"},{"location":"api/#usages","text":"","title":"Usages"},{"location":"api/#cli","text":"clojure-lsp --help should show all available commands and options.","title":"CLI"},{"location":"api/#library","text":"The namespace clojure-lsp.api should be used as the entrypoint for all available features of the CLI and some specific for library only usage, feel free to open a issue for missing features. Below is an example using the clean-ns feature on a deps.edn project: { :aliases { :lint-ns { :replace-deps { com.github.clojure-lsp/clojure-lsp { :mvn/version \"...\" }} :exec-fn clojure-lsp.api/clean-ns! :exec-args { :dry? true }}}}","title":"Library"},{"location":"api/#ci","text":"You can use setup-clojure-lsp GitHub action to install clojure-lsp in a CI. Remember to install your build tool, like clojure or leiningen as well in your CI according to your project to clojure-lsp be able to scan the classpath correctly.","title":"CI"},{"location":"api/#leiningen","text":"To run clojure-lsp from Leiningen easily, check lein-clojure-lsp plugin.","title":"Leiningen"},{"location":"api/#babashka-pod","text":"It's possible to load clojure-lsp as a babashka pod giving access to the clojure-lsp.api namespace, Check babashka pod registry example .","title":"Babashka pod"},{"location":"api/#settings","text":"clojure-lsp will check for .lsp/config.edn in the project or home dir, but it's possible to force override the settings via the :settings option of the API or --settings option of the CLI. For all available settings, check the settings section documentation .","title":"Settings"},{"location":"building/","text":"Building # GraalVM # Every release, the native binaries (Windows, Linux and MacOS) are compiled with GraalVM and uploaded to Github releases page. To build a native image with GraalVM: Install the GraalVM 22.0.0.2 for Java 11 and set the GRAALVM_HOME to the installation dir. Install native-image with $GRAALVM_HOME/bin/gu install native-image . Unix: Run from clojure-lsp project root make native-cli Windows: cd cli && ./graalvm/native-windows-compile.bat . The build may take some minutes and the result will be a ./clojure-lsp native binary. Debug / development # Run make or make debug-cli . Jar # Editor/CLI # Run make cli-jar for building the jar to be used with LSP protocol in a editor or CLI. JVM API # Run make lib-jar for building the jar to be used on JVM via API.","title":"Building"},{"location":"building/#building","text":"","title":"Building"},{"location":"building/#graalvm","text":"Every release, the native binaries (Windows, Linux and MacOS) are compiled with GraalVM and uploaded to Github releases page. To build a native image with GraalVM: Install the GraalVM 22.0.0.2 for Java 11 and set the GRAALVM_HOME to the installation dir. Install native-image with $GRAALVM_HOME/bin/gu install native-image . Unix: Run from clojure-lsp project root make native-cli Windows: cd cli && ./graalvm/native-windows-compile.bat . The build may take some minutes and the result will be a ./clojure-lsp native binary.","title":"GraalVM"},{"location":"building/#debug-development","text":"Run make or make debug-cli .","title":"Debug / development"},{"location":"building/#jar","text":"","title":"Jar"},{"location":"building/#editorcli","text":"Run make cli-jar for building the jar to be used with LSP protocol in a editor or CLI.","title":"Editor/CLI"},{"location":"building/#jvm-api","text":"Run make lib-jar for building the jar to be used on JVM via API.","title":"JVM API"},{"location":"capabilities/","text":"Capabilities # Implementation Status # Below are all the currently supported LSP capabilities and their implementation status: capability done notes initialize \u221a initialized \u221a shutdown \u221a exit \u221a $/cancelRequest $/progress \u221a window/showDocument \u221a window/showMessage \u221a window/showMessageRequest \u221a window/logMessage window/workDoneProgress/create window/workDoneProgress/cancel telemetry/event client/registerCapability \u221a client/unregisterCapability workspace/workspaceFolders workspace/didChangeWorkspaceFolders workspace/didChangeConfiguration \u221a Currently does nothing but log workspace/configuration We use a more robust settings concept (.lsp/config.edn) workspace/didChangeWatchedFiles \u221a workspace/symbol \u221a workspace/executeCommand \u221a See Extra capabilities workspace/applyEdit \u221a TextDocumentEdit and RenameFile only textDocument/didOpen \u221a textDocument/didChange \u221a textDocument/willSave textDocument/willSaveWaitUntil textDocument/didSave \u221a Do nothing currently textDocument/didClose \u221a textDocument/publishDiagnostics \u221a textDocument/completion \u221a completionItem/resolve \u221a textDocument/hover \u221a textDocument/signatureHelp \u221a Missing support for active parameter ATM textDocument/declaration \u221a Show where the symbol was declared on the file, like alias/refer definitions textDocument/definition \u221a textDocument/typeDefinition textDocument/implementation \u221a Implementation of defprotocols/defmulti showing deftypes and defrecords textDocument/references \u221a textDocument/documentHighlight \u221a textDocument/documentSymbol \u221a textDocument/codeAction \u221a codeAction/resolve \u221a textDocument/codeLens \u221a codeLens/resolve \u221a textDocument/documentLink documentLink/resolve textDocument/documentColor textDocument/colorPresentation textDocument/formatting \u221a textDocument/rangeFormatting \u221a textDocument/onTypeFormatting textDocument/rename \u221a textDocument/prepareRename \u221a textDocument/foldingRange textDocument/selectionRange textDocument/semanticTokens/full \u221a textDocument/semanticTokens/full/delta textDocument/semanticTokens/range \u221a workspace/semanticTokens/refresh workspace/codeLens/refresh \u221a textDocument/linkedEditingRange \u221a textDocument/prepareCallHierarchy \u221a callHierarchy/incomingCalls \u221a callHierarchy/outgoingCalls \u221a textDocument/moniker Extra capabilities # Besides LSP official capabilities, clojure-lsp has some extra features: Refactorings # It should be possible to introduce most of the refactorings here More details # Calling executeCommand with the following commands and additional args will notify the client with applyEdit . All commands expect the first three args to be [document-uri, line, column] (eg [\"file:///home/snoe/file.clj\", 13, 11] ) done command args notes \u221a add-import-to-namespace [document-uri, line, column, import-name] \u221a add-missing-libspec \u221a clean-ns \u221a cycle-coll \u221a cycle-privacy \u221a expand-let \u221a extract-function [document-uri, line, column, function-name] \u221a inline-symbol \u221a introduce-let [document-uri, line, column, binding-name] \u221a move-to-let [document-uri, line, column, binding-name] \u221a thread-first \u221a thread-first-all \u221a thread-last \u221a thread-last-all \u221a unwind-all \u221a unwind-thread \u221a resolve-macro-as [document-uri, line, column, resolved-full-symbol kondo-config-path] \u221a create-test See Vim client section for an example. Emacs provides all those refactorings via lsp-mode with the lsp-clojure- prefix. Other clients might provide a higher level interface to workspace/executeCommand you need to pass the path, line and column numbers. Custom methods # clojure-lsp has some custom LSP methods that doesn't follow the protocol but aggregate value as a clojure IDE: Test tree # Notify client with test tree data to build a UI tree on client side. Type: Server Notification Capability: experimental.testTree Method: clojure/textDocument/testTree Response: TestTreeParams TestTreeParams : {:uri string, :tree TestTreeNode} TestTreeNode : {:name string, name-range: Range, range: Range, :kind TestTreeKind, :children [TestTreeNode]} TestTreeKind : :namespace 1 :deftest 2 | :testing 3 Server Info Raw # Use to retrieve from server the server configuration information. Type: Client request with response Capability: none Method: clojure/serverInfo/raw Params: none Response: Any Server Info Log # Use to log to client the server configuration information. Type: Client request with response Capability: none Method: clojure/serverInfo/log Params: none Response: none Cursor Info Log # Use to log to client the debugging information for the symbol at cursor. Type: Client request with response Capability: none Method: clojure/cursorInfo/log Params: [uri, line, column] Response: Any Clojuredocs raw # Use to retrieve any Clojuredocs entry. Will return null if no entry found. Type: Client request with response Capability: none Method: clojure/clojuredocs/raw Params: [symbol-name, symbol-ns] Response: Any","title":"Capabilities"},{"location":"capabilities/#capabilities","text":"","title":"Capabilities"},{"location":"capabilities/#implementation-status","text":"Below are all the currently supported LSP capabilities and their implementation status: capability done notes initialize \u221a initialized \u221a shutdown \u221a exit \u221a $/cancelRequest $/progress \u221a window/showDocument \u221a window/showMessage \u221a window/showMessageRequest \u221a window/logMessage window/workDoneProgress/create window/workDoneProgress/cancel telemetry/event client/registerCapability \u221a client/unregisterCapability workspace/workspaceFolders workspace/didChangeWorkspaceFolders workspace/didChangeConfiguration \u221a Currently does nothing but log workspace/configuration We use a more robust settings concept (.lsp/config.edn) workspace/didChangeWatchedFiles \u221a workspace/symbol \u221a workspace/executeCommand \u221a See Extra capabilities workspace/applyEdit \u221a TextDocumentEdit and RenameFile only textDocument/didOpen \u221a textDocument/didChange \u221a textDocument/willSave textDocument/willSaveWaitUntil textDocument/didSave \u221a Do nothing currently textDocument/didClose \u221a textDocument/publishDiagnostics \u221a textDocument/completion \u221a completionItem/resolve \u221a textDocument/hover \u221a textDocument/signatureHelp \u221a Missing support for active parameter ATM textDocument/declaration \u221a Show where the symbol was declared on the file, like alias/refer definitions textDocument/definition \u221a textDocument/typeDefinition textDocument/implementation \u221a Implementation of defprotocols/defmulti showing deftypes and defrecords textDocument/references \u221a textDocument/documentHighlight \u221a textDocument/documentSymbol \u221a textDocument/codeAction \u221a codeAction/resolve \u221a textDocument/codeLens \u221a codeLens/resolve \u221a textDocument/documentLink documentLink/resolve textDocument/documentColor textDocument/colorPresentation textDocument/formatting \u221a textDocument/rangeFormatting \u221a textDocument/onTypeFormatting textDocument/rename \u221a textDocument/prepareRename \u221a textDocument/foldingRange textDocument/selectionRange textDocument/semanticTokens/full \u221a textDocument/semanticTokens/full/delta textDocument/semanticTokens/range \u221a workspace/semanticTokens/refresh workspace/codeLens/refresh \u221a textDocument/linkedEditingRange \u221a textDocument/prepareCallHierarchy \u221a callHierarchy/incomingCalls \u221a callHierarchy/outgoingCalls \u221a textDocument/moniker","title":"Implementation Status"},{"location":"capabilities/#extra-capabilities","text":"Besides LSP official capabilities, clojure-lsp has some extra features:","title":"Extra capabilities"},{"location":"capabilities/#refactorings","text":"It should be possible to introduce most of the refactorings here","title":"Refactorings"},{"location":"capabilities/#more-details","text":"Calling executeCommand with the following commands and additional args will notify the client with applyEdit . All commands expect the first three args to be [document-uri, line, column] (eg [\"file:///home/snoe/file.clj\", 13, 11] ) done command args notes \u221a add-import-to-namespace [document-uri, line, column, import-name] \u221a add-missing-libspec \u221a clean-ns \u221a cycle-coll \u221a cycle-privacy \u221a expand-let \u221a extract-function [document-uri, line, column, function-name] \u221a inline-symbol \u221a introduce-let [document-uri, line, column, binding-name] \u221a move-to-let [document-uri, line, column, binding-name] \u221a thread-first \u221a thread-first-all \u221a thread-last \u221a thread-last-all \u221a unwind-all \u221a unwind-thread \u221a resolve-macro-as [document-uri, line, column, resolved-full-symbol kondo-config-path] \u221a create-test See Vim client section for an example. Emacs provides all those refactorings via lsp-mode with the lsp-clojure- prefix. Other clients might provide a higher level interface to workspace/executeCommand you need to pass the path, line and column numbers.","title":"More details"},{"location":"capabilities/#custom-methods","text":"clojure-lsp has some custom LSP methods that doesn't follow the protocol but aggregate value as a clojure IDE:","title":"Custom methods"},{"location":"capabilities/#test-tree","text":"Notify client with test tree data to build a UI tree on client side. Type: Server Notification Capability: experimental.testTree Method: clojure/textDocument/testTree Response: TestTreeParams TestTreeParams : {:uri string, :tree TestTreeNode} TestTreeNode : {:name string, name-range: Range, range: Range, :kind TestTreeKind, :children [TestTreeNode]} TestTreeKind : :namespace 1 :deftest 2 | :testing 3","title":"Test tree"},{"location":"capabilities/#server-info-raw","text":"Use to retrieve from server the server configuration information. Type: Client request with response Capability: none Method: clojure/serverInfo/raw Params: none Response: Any","title":"Server Info Raw"},{"location":"capabilities/#server-info-log","text":"Use to log to client the server configuration information. Type: Client request with response Capability: none Method: clojure/serverInfo/log Params: none Response: none","title":"Server Info Log"},{"location":"capabilities/#cursor-info-log","text":"Use to log to client the debugging information for the symbol at cursor. Type: Client request with response Capability: none Method: clojure/cursorInfo/log Params: [uri, line, column] Response: Any","title":"Cursor Info Log"},{"location":"capabilities/#clojuredocs-raw","text":"Use to retrieve any Clojuredocs entry. Will return null if no entry found. Type: Client request with response Capability: none Method: clojure/clojuredocs/raw Params: [symbol-name, symbol-ns] Response: Any","title":"Clojuredocs raw"},{"location":"clients/","text":"Clients # Clients are either editors with built in LSP support like Oni or nvim, or an appropriate plugin. Clients are responsible for launching the server, the server is a subprocess of your editor not a daemon. In general, make sure to configure the client to use stdio and a server launch command like ['/usr/local/bin/clojure-lsp'] . If that fails, you may need to have your client launch inside a shell, so use something like ['bash', '-c', '/usr/local/bin/clojure-lsp'] . In windows you probably need to use the clojure-lsp.bat . TIP : If your editor is not started from the terminal then it is possible that its $PATH is quite different from the one in the shell and clojure-lsp will not be able to find the executables it needs, such as clojure and npx . To alleviate that, create a wrapper script that sets the PATH correctly. Make sure that nothing in the script uses stdin / stdout as these are used for communication with the editor and any extra input/output could mess it up. An example script (also remember to make it executable, e.g. chmod u+x <script> ): #!/bin/bash -l if [ ! -e npx ] ; then export PATH = $PATH :/Users/me/.nvm/versions/node/v10.24.1/bin fi exec /usr/local/bin/clojure-lsp Emacs # lsp-mode has built in support for clojure-lsp . With use-package , add the following to your emacs config: ( use-package lsp-mode :ensure t :hook (( clojure-mode . lsp ) ( clojurec-mode . lsp ) ( clojurescript-mode . lsp )) :config ;; add paths to your local installation of project mgmt tools, like lein ( setenv \"PATH\" ( concat \"/usr/local/bin\" path-separator ( getenv \"PATH\" ))) ( dolist ( m ' ( clojure-mode clojurec-mode clojurescript-mode clojurex-mode )) ( add-to-list 'lsp-language-id-configuration ` ( , m . \"clojure\" ))) ( setq lsp-clojure-server-command ' ( \"/path/to/clojure-lsp\" ))) ;; Optional: In case `clojure-lsp` is not in your $PATH Optionally you can add lsp-ui for UI feedback and company-mode for completion: ( use-package lsp-ui :ensure t :commands lsp-ui-mode ) ( use-package company :ensure t ) In lsp-mode , lsp-clojure-server-command variable is available to override the command to start the clojure-lsp server, might be necessary to do this on a Windows environment. For a detailed guide on how to configure Emacs with LSP, check here For more lsp-mode clojure settings, check here Visual Studio Code # Calva is a extension for VSCode for Clojure Development that includes clojure-lsp. Vim # I prefer https://github.com/neoclide/coc.nvim but both http://github.com/autozimu/LanguageClient-neovim and https://github.com/prabirshrestha/vim-lsp work well. See my nvim/init.vim and coc-settings.json Another example of a Neovim Conjure/CoC/clojure-lsp setup can be found on dharrigan's github repository. LanguageClient-neovim can be configure with: Refactorings: function ! Expand ( exp ) abort let l :result = expand ( a :exp ) return l :result == # '' ? '' : \"file://\" . l :result endfunction nnoremap < silent > crcc : call LanguageClient#workspace_executeCommand ( 'cycle-coll' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crth : call LanguageClient#workspace_executeCommand ( 'thread-first' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtt : call LanguageClient#workspace_executeCommand ( 'thread-last' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtf : call LanguageClient#workspace_executeCommand ( 'thread-first-all' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtl : call LanguageClient#workspace_executeCommand ( 'thread-last-all' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crml : call LanguageClient#workspace_executeCommand ( 'move-to-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 , input ( 'Binding name: ' ) ] )< CR > nnoremap < silent > cril : call LanguageClient#workspace_executeCommand ( 'introduce-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 , input ( 'Binding name: ' ) ] )< CR > nnoremap < silent > crel : call LanguageClient#workspace_executeCommand ( 'expand-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > cram : call LanguageClient#workspace_executeCommand ( 'add-missing-libspec' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > initializationOptions can be sent by setting: let g:LanguageClient_settingsPath=\".lsp/settings.json\" Project-local .lsp/settings.json would have content like: { \"initializationOptions\" : { \"source-paths\" : [ \"shared-src\" , \"src\" , \"test\" , \"dashboard/src\" ] , \"macro-defs\" : { \"project.macros/dofor\" : [ \"bindings\" , \"bound-elements\" ]}}} Further refactoring mappings include being able to invoke the (coc-codeaction-*) function to provide actions such as move to let , change coll to map and so on. nmap <silent> <Leader>cr <Plug>(coc-rename) nmap <silent> <Leader>cf <Plug>(coc-references) xmap <silent> <Leader>c <Plug>(coc-codeaction-selected) nmap <silent> <Leader>c <Plug>(coc-codeaction-line) nmap <silent> gd <Plug>(coc-definition) Nvim # An very detailed document about how configure Nvim as Clojure IDE using fennel, clojure-lsp and conjure. nvim-fennel-lsp-conjure-as-clojure-ide Sublime Text # Clojure LSP can be installed by first installing the LSP plugin which brings Language Server Protocol support to Sublime Text editor and then following the set-up instructions here to download Clojure LSP and how to configure it in Sublime Text. Intellij # Install the LSP Support plugin and configure it to launch clojure-lsp for Clojure/Script files: Go to Preferences / Languages & Frameworks / Language Server Protocol / Server Definitions. Select Raw command . In the Extension field enter clj;cljs;cljc;edn . In the Command field enter the path to the executable, for instance /usr/local/bin/clojure-lsp . BEWARE: The LSP Support plugin has short timeouts and will kill clojure-lsp silently if it exceeds the limit. It is highly recommended that you increase the Init timeout from 10000 (10s) to e.g. 300000 (5 min). The first scan can easily take over a minute on a bigger project. See Preferences / Languages & Frameworks / Language Server Protocol / Timeouts. If the plugin's icon in the status bar (a circle) turns red, it means starting clojure-lsp failed. Click on it and select Show timeouts - any limits that were exceeded will be in red. Oni # Seems to work reasonably well but couldn't get rename to work reliably https://github.com/onivim/oni Atom # I tried making a client but my hello world attempt didn't seem to work. If someone wants to take this on, I'd be willing to package it here too.","title":"Clients"},{"location":"clients/#clients","text":"Clients are either editors with built in LSP support like Oni or nvim, or an appropriate plugin. Clients are responsible for launching the server, the server is a subprocess of your editor not a daemon. In general, make sure to configure the client to use stdio and a server launch command like ['/usr/local/bin/clojure-lsp'] . If that fails, you may need to have your client launch inside a shell, so use something like ['bash', '-c', '/usr/local/bin/clojure-lsp'] . In windows you probably need to use the clojure-lsp.bat . TIP : If your editor is not started from the terminal then it is possible that its $PATH is quite different from the one in the shell and clojure-lsp will not be able to find the executables it needs, such as clojure and npx . To alleviate that, create a wrapper script that sets the PATH correctly. Make sure that nothing in the script uses stdin / stdout as these are used for communication with the editor and any extra input/output could mess it up. An example script (also remember to make it executable, e.g. chmod u+x <script> ): #!/bin/bash -l if [ ! -e npx ] ; then export PATH = $PATH :/Users/me/.nvm/versions/node/v10.24.1/bin fi exec /usr/local/bin/clojure-lsp","title":"Clients"},{"location":"clients/#emacs","text":"lsp-mode has built in support for clojure-lsp . With use-package , add the following to your emacs config: ( use-package lsp-mode :ensure t :hook (( clojure-mode . lsp ) ( clojurec-mode . lsp ) ( clojurescript-mode . lsp )) :config ;; add paths to your local installation of project mgmt tools, like lein ( setenv \"PATH\" ( concat \"/usr/local/bin\" path-separator ( getenv \"PATH\" ))) ( dolist ( m ' ( clojure-mode clojurec-mode clojurescript-mode clojurex-mode )) ( add-to-list 'lsp-language-id-configuration ` ( , m . \"clojure\" ))) ( setq lsp-clojure-server-command ' ( \"/path/to/clojure-lsp\" ))) ;; Optional: In case `clojure-lsp` is not in your $PATH Optionally you can add lsp-ui for UI feedback and company-mode for completion: ( use-package lsp-ui :ensure t :commands lsp-ui-mode ) ( use-package company :ensure t ) In lsp-mode , lsp-clojure-server-command variable is available to override the command to start the clojure-lsp server, might be necessary to do this on a Windows environment. For a detailed guide on how to configure Emacs with LSP, check here For more lsp-mode clojure settings, check here","title":"Emacs"},{"location":"clients/#visual-studio-code","text":"Calva is a extension for VSCode for Clojure Development that includes clojure-lsp.","title":"Visual Studio Code"},{"location":"clients/#vim","text":"I prefer https://github.com/neoclide/coc.nvim but both http://github.com/autozimu/LanguageClient-neovim and https://github.com/prabirshrestha/vim-lsp work well. See my nvim/init.vim and coc-settings.json Another example of a Neovim Conjure/CoC/clojure-lsp setup can be found on dharrigan's github repository. LanguageClient-neovim can be configure with: Refactorings: function ! Expand ( exp ) abort let l :result = expand ( a :exp ) return l :result == # '' ? '' : \"file://\" . l :result endfunction nnoremap < silent > crcc : call LanguageClient#workspace_executeCommand ( 'cycle-coll' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crth : call LanguageClient#workspace_executeCommand ( 'thread-first' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtt : call LanguageClient#workspace_executeCommand ( 'thread-last' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtf : call LanguageClient#workspace_executeCommand ( 'thread-first-all' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtl : call LanguageClient#workspace_executeCommand ( 'thread-last-all' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crml : call LanguageClient#workspace_executeCommand ( 'move-to-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 , input ( 'Binding name: ' ) ] )< CR > nnoremap < silent > cril : call LanguageClient#workspace_executeCommand ( 'introduce-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 , input ( 'Binding name: ' ) ] )< CR > nnoremap < silent > crel : call LanguageClient#workspace_executeCommand ( 'expand-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > cram : call LanguageClient#workspace_executeCommand ( 'add-missing-libspec' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > initializationOptions can be sent by setting: let g:LanguageClient_settingsPath=\".lsp/settings.json\" Project-local .lsp/settings.json would have content like: { \"initializationOptions\" : { \"source-paths\" : [ \"shared-src\" , \"src\" , \"test\" , \"dashboard/src\" ] , \"macro-defs\" : { \"project.macros/dofor\" : [ \"bindings\" , \"bound-elements\" ]}}} Further refactoring mappings include being able to invoke the (coc-codeaction-*) function to provide actions such as move to let , change coll to map and so on. nmap <silent> <Leader>cr <Plug>(coc-rename) nmap <silent> <Leader>cf <Plug>(coc-references) xmap <silent> <Leader>c <Plug>(coc-codeaction-selected) nmap <silent> <Leader>c <Plug>(coc-codeaction-line) nmap <silent> gd <Plug>(coc-definition)","title":"Vim"},{"location":"clients/#nvim","text":"An very detailed document about how configure Nvim as Clojure IDE using fennel, clojure-lsp and conjure. nvim-fennel-lsp-conjure-as-clojure-ide","title":"Nvim"},{"location":"clients/#sublime-text","text":"Clojure LSP can be installed by first installing the LSP plugin which brings Language Server Protocol support to Sublime Text editor and then following the set-up instructions here to download Clojure LSP and how to configure it in Sublime Text.","title":"Sublime Text"},{"location":"clients/#intellij","text":"Install the LSP Support plugin and configure it to launch clojure-lsp for Clojure/Script files: Go to Preferences / Languages & Frameworks / Language Server Protocol / Server Definitions. Select Raw command . In the Extension field enter clj;cljs;cljc;edn . In the Command field enter the path to the executable, for instance /usr/local/bin/clojure-lsp . BEWARE: The LSP Support plugin has short timeouts and will kill clojure-lsp silently if it exceeds the limit. It is highly recommended that you increase the Init timeout from 10000 (10s) to e.g. 300000 (5 min). The first scan can easily take over a minute on a bigger project. See Preferences / Languages & Frameworks / Language Server Protocol / Timeouts. If the plugin's icon in the status bar (a circle) turns red, it means starting clojure-lsp failed. Click on it and select Show timeouts - any limits that were exceeded will be in red.","title":"Intellij"},{"location":"clients/#oni","text":"Seems to work reasonably well but couldn't get rename to work reliably https://github.com/onivim/oni","title":"Oni"},{"location":"clients/#atom","text":"I tried making a client but my hello world attempt didn't seem to work. If someone wants to take this on, I'd be willing to package it here too.","title":"Atom"},{"location":"development/","text":"clojure-lsp Development # There are several ways of finding and fixing a bug or implementing a new feature: The Clojure Way Create a test for your bug/feature, then implement the code following the test (TDD). Build clojure-lsp using make each time you have made changes, and test it manually in your client. This is the slowest option. Whichever development path you choose: For final testing, it is good to rebuild the binary with make . There are two custom LSP methods clojure/serverInfo/log and clojure/cursorInfo/log . They can assist in debugging. The Clojure Way # With a clojure-lsp + nREPL powered Clojure editor you can modify your editor session's clojure-lsp server using the Clojure REPL. Here's demo video: https://www.youtube.com/watch?v=4UvT0yqBDw8 These are the steps: make - to build a clojure-lsp executable that includes cider-nrepl in the jar. This executable will be saved at the root of the project. Configure your editor to use this clojure-lsp executable Have your editor restart its clojure-lsp server Issue the clojure-lsp serverInfo command Find the port entry in the output Connect your editors nREPL client to this port Hack away! Seeing is believing. An easy way to convince yourself that you can actually change clojure-lsp mid-flight is to: Modify the server-info function in src/clojure_lsp/handlers.clj Say, you add a :foo :bar entry to the map returned Evaluate the new server-info function definition Issue the clojure-lsp serverInfo command Find :foo :bar in the output You have just modified the LSP server powering your editor while it was running! This is the Clojure way. No recompiling and restarting and reloading. That is some other, non-Clojure, way. The details in how to perform these steps can vary a bit between the various Clojure editors/plugins. Visual Studio Code with Calva # This project comes with Calva configuration to use the clojure-lsp executable built in step 1 above. You can skip step 2. To restart the clojure-lsp server, use the VS Code command Developer: Reload Window The Hack away! step needs to start with you issuing the command Calva: Load Current File and Dependencies . Emacs with CIDER # To configure Emacs to use the nREPL-enabled executable, run (setq lsp-clojure-custom-server-command '(\"~/path/to/clojure-lsp/clojure-lsp\")) , adjusting the path as necessary. If you add this to your Emacs config, you can skip this step in the future. To restart the clojure-lsp server, execute the Emacs command lsp-workspace-restart . To find the server info, execute lsp-clojure-server-info . To connect the nREPL client, run cider-connect-clj , with \"localhost\" and the port. If you re-connect regulary, you may want to add this Emacs shortcut: ( defun lsp-clojure-nrepl-connect () \"Connect to the running nrepl debug server of clojure-lsp.\" ( interactive ) ( let (( info ( lsp-clojure-server-info-raw ))) ( save-match-data ( when-let ( port ( and ( string-match \"\\\"port\\\":\\\\([0-9]+\\\\)\" info ) ( match-string 1 info ))) ( cider-connect-clj ` ( :host \"localhost\" :port , port )))))) Vim with coc.nvim and Fireplace # Change coc-settings.json ( :CocConfig ) clojure-lsp: {command: \"~/path/to/clojure-lsp/clojure-lsp\"} , adjusting the past as necessary. To restart the clojure-lsp server use :CocRestart To find the server info, :echo CocRequest('clojure-lsp', 'clojure/serverInfo/raw')['port'] To find the server log, :echo CocRequest('clojure-lsp', 'clojure/serverInfo/raw')['log-path'] To connect the nREPL client, run :Connect <port> If you re-connect regulary, you may want to add something like this to your vimrc: \" Copies the log-path to your clipboard nnoremap <silent> crsl :call setreg('*', CocRequest('clojure-lsp', 'clojure/serverInfo/raw')['log-path'])<CR> \" Connects to nrepl nnoremap <silent> crsp :execute 'Connect' CocRequest('clojure-lsp', 'clojure/serverInfo/raw')['port']<CR> Your Favorite Editor # TBD. PR welcome. Debugging & Profiling # The nREPL includes tools for debugging and profiling clojure-lsp. See cli/dev/clojure_lsp/debug.clj . If you're interested in using the profiling tools in that file, you'll need to be familiar with criterium and clj-async-profiler . Note that the performance of clojure-lsp is highly dependent on the size of its db. If you load a repl with -A:build , you'll have access to the debugging tools, but the db will be nearly empty. Follow the [steps][#the-clojure-way] above to connect to an nREPL which has a populated db.","title":"Development"},{"location":"development/#clojure-lsp-development","text":"There are several ways of finding and fixing a bug or implementing a new feature: The Clojure Way Create a test for your bug/feature, then implement the code following the test (TDD). Build clojure-lsp using make each time you have made changes, and test it manually in your client. This is the slowest option. Whichever development path you choose: For final testing, it is good to rebuild the binary with make . There are two custom LSP methods clojure/serverInfo/log and clojure/cursorInfo/log . They can assist in debugging.","title":"clojure-lsp Development"},{"location":"development/#the-clojure-way","text":"With a clojure-lsp + nREPL powered Clojure editor you can modify your editor session's clojure-lsp server using the Clojure REPL. Here's demo video: https://www.youtube.com/watch?v=4UvT0yqBDw8 These are the steps: make - to build a clojure-lsp executable that includes cider-nrepl in the jar. This executable will be saved at the root of the project. Configure your editor to use this clojure-lsp executable Have your editor restart its clojure-lsp server Issue the clojure-lsp serverInfo command Find the port entry in the output Connect your editors nREPL client to this port Hack away! Seeing is believing. An easy way to convince yourself that you can actually change clojure-lsp mid-flight is to: Modify the server-info function in src/clojure_lsp/handlers.clj Say, you add a :foo :bar entry to the map returned Evaluate the new server-info function definition Issue the clojure-lsp serverInfo command Find :foo :bar in the output You have just modified the LSP server powering your editor while it was running! This is the Clojure way. No recompiling and restarting and reloading. That is some other, non-Clojure, way. The details in how to perform these steps can vary a bit between the various Clojure editors/plugins.","title":"The Clojure Way"},{"location":"development/#visual-studio-code-with-calva","text":"This project comes with Calva configuration to use the clojure-lsp executable built in step 1 above. You can skip step 2. To restart the clojure-lsp server, use the VS Code command Developer: Reload Window The Hack away! step needs to start with you issuing the command Calva: Load Current File and Dependencies .","title":"Visual Studio Code with Calva"},{"location":"development/#emacs-with-cider","text":"To configure Emacs to use the nREPL-enabled executable, run (setq lsp-clojure-custom-server-command '(\"~/path/to/clojure-lsp/clojure-lsp\")) , adjusting the path as necessary. If you add this to your Emacs config, you can skip this step in the future. To restart the clojure-lsp server, execute the Emacs command lsp-workspace-restart . To find the server info, execute lsp-clojure-server-info . To connect the nREPL client, run cider-connect-clj , with \"localhost\" and the port. If you re-connect regulary, you may want to add this Emacs shortcut: ( defun lsp-clojure-nrepl-connect () \"Connect to the running nrepl debug server of clojure-lsp.\" ( interactive ) ( let (( info ( lsp-clojure-server-info-raw ))) ( save-match-data ( when-let ( port ( and ( string-match \"\\\"port\\\":\\\\([0-9]+\\\\)\" info ) ( match-string 1 info ))) ( cider-connect-clj ` ( :host \"localhost\" :port , port ))))))","title":"Emacs with CIDER"},{"location":"development/#vim-with-cocnvim-and-fireplace","text":"Change coc-settings.json ( :CocConfig ) clojure-lsp: {command: \"~/path/to/clojure-lsp/clojure-lsp\"} , adjusting the past as necessary. To restart the clojure-lsp server use :CocRestart To find the server info, :echo CocRequest('clojure-lsp', 'clojure/serverInfo/raw')['port'] To find the server log, :echo CocRequest('clojure-lsp', 'clojure/serverInfo/raw')['log-path'] To connect the nREPL client, run :Connect <port> If you re-connect regulary, you may want to add something like this to your vimrc: \" Copies the log-path to your clipboard nnoremap <silent> crsl :call setreg('*', CocRequest('clojure-lsp', 'clojure/serverInfo/raw')['log-path'])<CR> \" Connects to nrepl nnoremap <silent> crsp :execute 'Connect' CocRequest('clojure-lsp', 'clojure/serverInfo/raw')['port']<CR>","title":"Vim with coc.nvim and Fireplace"},{"location":"development/#your-favorite-editor","text":"TBD. PR welcome.","title":"Your Favorite Editor"},{"location":"development/#debugging-profiling","text":"The nREPL includes tools for debugging and profiling clojure-lsp. See cli/dev/clojure_lsp/debug.clj . If you're interested in using the profiling tools in that file, you'll need to be familiar with criterium and clj-async-profiler . Note that the performance of clojure-lsp is highly dependent on the size of its db. If you load a repl with -A:build , you'll have access to the debugging tools, but the db will be nearly empty. Follow the [steps][#the-clojure-way] above to connect to an nREPL which has a populated db.","title":"Debugging &amp; Profiling"},{"location":"features/","text":"Features # Below you can find all available features that clojure-lsp provides with examples using Emacs lsp-mode as the client. Built in LSP features clojure-lsp extra commands LSP features # Find a function/var definition # Find defprotocol/defmulti implementations # Find a function/var declaration in the ns # Find all references of a function, var, keyword or namespace alias # Show all workspace/project symbols # Show all symbols on current file # Rename symbols # Also, it's possible to live rename symbols on the same buffer with linkedEditingRange feature. Document highlight on hover showing symbol usages # Documentation and clojuredocs integration # Java support # To understand what is supported and how to configure it, check the settings section . Completion # Snippets # Snippets are templates that make it easier to enter repeating code patterns, such as common functions/forms, they are available during completion. Tabstops are defined as $number with $0 as last tabstop. Check all available snippets here name description raw content comment Insert comment block (comment\\n ${0:body}\\n ) comment-heading Insert comment Header ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\\n;; ${1:Namespace summary title}\\n;;\\n;; ${2:Brief description}\\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\\n\\n$0 comment-separator Insert comment separator ;; ${1:Namespace summary title}\\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\\n\\n$0 rich-comment Insert rich comment (comment $0 #_()) rich-comment-rdd Insert rich comment rdd block #_{:clj-kondo/ignore [:redefined-var]}\\n(comment\\n $0 #_()) rich-comment-hotload Insert rich comment library hotload #_{:clj-kondo/ignore [:redefined-var]}\\n(comment\\n ;; Add-lib library for hot-loading\\n (require '[clojure.tools.deps.alpha.repl :refer [add-libs]])\\n (add-libs '{${1:domain/library-name} {:mvn/version \\\"${2:1.0.0}\\\"}$3})\\n $0\\n) condp Insert condp (condp ${1:pred} ${2:expr}\\n $0) def Insert def (def ${1:name} $0) def- Insert def private (def ^:private ${1:name} $0) def-doc Insert def with docstring (def ${1:name}\\n \\\"${2:docstring}\\\"\\n $0) defmethod Insert defmethod (defmethod ${1:name} ${2:match}\\n [${3:args}]\\n $0) defmulti Insert defmulti (defmulti ${1:name} ${2:dispatch-fn}) defn Insert public defn (defn ${1:name} [$2]\\n $0) defn-doc Insert public defn with docstring (defn ${1:name}\\n \\\"${2:docstring}\\\"\\n [${3:args}]\\n $0) defn- Insert private defn (defn%s ${1:name} [$2]\\n $0) defprotocol Insert defprotocol (defprotocol ${1:Name}\\n $0) defrecord Insert defrecord (defrecord ${1:Name} [${2:fields}]\\n ${3:Protocol}\\n $0) deftype Insert deftype (deftype ${1:Name} [${2:fields}]\\n ${3:Protocol}\\n $0) fn Insert fn (fn [${1:arg-list}] $0) for Insert for (for [${1:item} ${2:coll}]\\n $0) if Insert if (if ${1:test-expr}\\n ${2:then-expr}\\n ${3:else-expr}) kwargs Insert keyword args {:keys [${1:keys}] :or {${2:defaults}}} let Insert let (let [$0]) letfn Insert letfn (letfn [(${1:name} [${2:args}]\\n $0)]) ns Insert ns (ns ${1:name}\\n $0:references}) ns-doc Insert ns with docstring (ns ${1:name}\\n \\\"${2:docstring}\\\"\\n ${0:references}) require Insert ns :require (:require [${1:namespace}])$0 require-as Insert ns require with :as alias (:require [${1:namespace} :as ${2:alias}]$3) require-refer Insert ns :require with :refer (:require [${1:namespace} :refer [$2]]$3) require-rdd Insert require for rich comment experiments (require '[${1:namespace} :as ${2:alias}]$3)$0 req-as Insert single require dep :as alias [${1:namespace} :as ${2:alias}] req-refer Insert single require dep with :refer [${1:namespace} :refer [$2]] import Insert import (:import [${1:package}]) use Insert require refer preferred over use (:require [${1:namespace} :refer [$2]]) deps-alias Insert alias with extra path & deps :${1:category/name}\\n {:extra-paths [\\\"${2:path}\\\"]\\n :extra-deps {${3:deps-maven or deps-git}}}$0 deps-maven Insert maven dependency ${1:domain/library-name} {:mvn/version \\\"${2:1.0.0}\\\"}$0 deps-git Insert git dependency ${1:domain/library-name}\\n {:git/sha \\\"${2:git-sha-value}\\\"}$0 deps-git-tag Insert git tag dependency ${1:domain/library-name}\\n {:git/tag \\\"${2:git-tag-value}\\\"\\n :git/sha \\\"${3:git-sha-value}\\\"}$0 deps-git-url Insert git URL dependency ${1:domain/library-name}\\n {:git/url \\\"https://github.com/$1\\\"\\n :git/sha \\\"${2:git-sha-value}\\\"}$0 deps-local Insert local dependency ${1:domain/library-name} {:local/root \\\"${2:/path/to/project/root}\\\"}$0 deftest Insert deftest clojure.test (deftest ${1:name}-test\\n (testing \\\"${2:Context of the test assertions}\\\"\\n (is (= ${3:assertion-values}))$4)) $0 testing Insert testing clojure.test (testing \\\"${1:Context of the test assertions}\\\"\\n $0) is Insert is clojure.test (is (= ${1:assertion-values})) Custom snippets # User can register additional custom snippets, for more information on how to configure it, check the snippets settings section . Code actions # See below for screenshots. Code lenses showing symbol references # Format a whole file or range # Signature help # Semantic tokens # The LSP server is the best to say what is the semantic value of a token on the editor, semantic tokens allows server return to client all tokens of a buffer and how client show apply highlight. Note: server return the semantic token (e.g. function ) and the client/editor apply the color that matches the user's theme. Call hierarchy # Show the incoming or outgoing call hierarchy of a function/variable as a lazy tree Incoming # Show functions that call the current one recursively Outgoing # Show functions that the current one call, recursively Test Tree # Show the tests tree hierarchy of a file Diagnostics (linter) # All linters besides the ones below come from clj-kondo that clojure-lsp calls under the hood to lint the code and retrieve the analysis to make most of features work. Every linter configuration should be done on clj-kondo side, so anything related to unresolved symbols or unknown macros are probably related to wrong clj-kondo for the project. For more information on how to configure clj-kondo check here . Below you can find the custom linters implemented on clojure-lsp side that uses the :custom-lint-fn from clj-kondo: clojure-lsp/unused-public-var # For more information on how to configure it, check the diagnostics settings section . Stub generation # It's possible to configure clojure-lsp to generate and analyze stubs for specific namespaces available on your project classpath, this is useful for closed source dependencies like datomic.api , with that clojure-lsp will be able to make most features work with those dependencies. For more information check the stubs settings section . Execute command # Commands that client can request. Most code actions use these commands as actions. clojure-lsp extra commands # Note: Most of these are available via code actions and clients or users may choose to use the code action menu to execute them instead of mapping. All functions in clojure-lsp have a two-letter mnemonic shortcut. E.g. tf for thread-first-all . We strongly suggest that client authors and users use these shortcuts keys when choosing to map these commands to key chords or menus; this allows for users to maintain muscle memory and familiarity as they switch between clients and editors. Thank you to clj-refactor for this system and other tools that adhere to it. LSP clients will allow you to bind these commands to shortcuts or menu items using LSP's workspace/executeCommand and passing a map with \"command\" and \"arguments\" keys. Arguments: - file-uri : Absolute file uri. e.x. file:///home/user/project/src/main.clj - row : line-number of the cursor, 0 based. - col : col-number of the cursor, 0 based. - name : Used when introducing a name, usually a string for a valid clojure symbol. - filename : Filename path. e.x. src/utils.clj Shortcut Command Name Arguments Available via code action Example ai add-import-to-namespace Add import to namespace [file-uri,row,col[,name]] \u2705 am add-missing-libspec Add missing require [file-uri,row,col] \u2705 as add-require-suggestion Add require suggestion [file-uri,row,col,ns,alias,refer] \u2705 cc cycle-coll Cycle collection (#{}, {}, [], ()) [file-uri,row,col] \u2705 cf cycle-fn-literal Cycle fn literal (fn []), #() [file-uri,row,col] \u2705 cn clean-ns Clean namespace [file-uri,row,col] \u2705 cp cycle-privacy Cycle privacy of def/defn [file-uri,row,col] \u2705 ct create-test Create test [file-uri,row,col] \u2705 db drag-backward Drag backward [file-uri,row,col] \u2705 df drag-forward Drag forward [file-uri,row,col] \u2705 ef extract-function Extract Function [file-uri,row,col,name] \u2705 el expand-let Expand let [file-uri,row,col] fe create-function Create function from example [file-uri,row,col] \u2705 il introduce-let Introduce let [file-uri,row,col,name] is inline-symbol Inline Symbol [file-uri,row,col] \u2705 ma resolve-macro-as Resolve macro as [file-uri,row,col] \u2705 mf move-form Move form [file-uri,row,col,filename] \u2705 ml move-to-let Move expression to let [file-uri,row,col,name] \u2705 sc change-collection Switch collection to {}, (), #{}, [] [file-uri,row,col,\"map\"/\"list\"/\"set\"/\"vector\"] \u2705 sm sort-map Sort map [file-uri,row,col] \u2705 tf thread-first-all Thread first all [file-uri,row,col] \u2705 th thread-first Thread first expression [file-uri,row,col] tl thread-last-all Thread last all [file-uri,row,col] \u2705 tt thread-last Thread last expression [file-uri,row,col] ua unwind-all Unwind all [file-uri,row,col] \u2705 uw unwind-thread Unwind thread [file-uri,row,col] Dev # Server information # Return basic information about the server. Cursor information # Return debug information about the element at point.","title":"Features"},{"location":"features/#features","text":"Below you can find all available features that clojure-lsp provides with examples using Emacs lsp-mode as the client. Built in LSP features clojure-lsp extra commands","title":"Features"},{"location":"features/#lsp-features","text":"","title":"LSP features"},{"location":"features/#find-a-functionvar-definition","text":"","title":"Find a function/var definition"},{"location":"features/#find-defprotocoldefmulti-implementations","text":"","title":"Find defprotocol/defmulti implementations"},{"location":"features/#find-a-functionvar-declaration-in-the-ns","text":"","title":"Find a function/var declaration in the ns"},{"location":"features/#find-all-references-of-a-function-var-keyword-or-namespace-alias","text":"","title":"Find all references of a function, var, keyword or namespace alias"},{"location":"features/#show-all-workspaceproject-symbols","text":"","title":"Show all workspace/project symbols"},{"location":"features/#show-all-symbols-on-current-file","text":"","title":"Show all symbols on current file"},{"location":"features/#rename-symbols","text":"Also, it's possible to live rename symbols on the same buffer with linkedEditingRange feature.","title":"Rename symbols"},{"location":"features/#document-highlight-on-hover-showing-symbol-usages","text":"","title":"Document highlight on hover showing symbol usages"},{"location":"features/#documentation-and-clojuredocs-integration","text":"","title":"Documentation and clojuredocs integration"},{"location":"features/#java-support","text":"To understand what is supported and how to configure it, check the settings section .","title":"Java support"},{"location":"features/#completion","text":"","title":"Completion"},{"location":"features/#snippets","text":"Snippets are templates that make it easier to enter repeating code patterns, such as common functions/forms, they are available during completion. Tabstops are defined as $number with $0 as last tabstop. Check all available snippets here name description raw content comment Insert comment block (comment\\n ${0:body}\\n ) comment-heading Insert comment Header ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\\n;; ${1:Namespace summary title}\\n;;\\n;; ${2:Brief description}\\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\\n\\n$0 comment-separator Insert comment separator ;; ${1:Namespace summary title}\\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\\n\\n$0 rich-comment Insert rich comment (comment $0 #_()) rich-comment-rdd Insert rich comment rdd block #_{:clj-kondo/ignore [:redefined-var]}\\n(comment\\n $0 #_()) rich-comment-hotload Insert rich comment library hotload #_{:clj-kondo/ignore [:redefined-var]}\\n(comment\\n ;; Add-lib library for hot-loading\\n (require '[clojure.tools.deps.alpha.repl :refer [add-libs]])\\n (add-libs '{${1:domain/library-name} {:mvn/version \\\"${2:1.0.0}\\\"}$3})\\n $0\\n) condp Insert condp (condp ${1:pred} ${2:expr}\\n $0) def Insert def (def ${1:name} $0) def- Insert def private (def ^:private ${1:name} $0) def-doc Insert def with docstring (def ${1:name}\\n \\\"${2:docstring}\\\"\\n $0) defmethod Insert defmethod (defmethod ${1:name} ${2:match}\\n [${3:args}]\\n $0) defmulti Insert defmulti (defmulti ${1:name} ${2:dispatch-fn}) defn Insert public defn (defn ${1:name} [$2]\\n $0) defn-doc Insert public defn with docstring (defn ${1:name}\\n \\\"${2:docstring}\\\"\\n [${3:args}]\\n $0) defn- Insert private defn (defn%s ${1:name} [$2]\\n $0) defprotocol Insert defprotocol (defprotocol ${1:Name}\\n $0) defrecord Insert defrecord (defrecord ${1:Name} [${2:fields}]\\n ${3:Protocol}\\n $0) deftype Insert deftype (deftype ${1:Name} [${2:fields}]\\n ${3:Protocol}\\n $0) fn Insert fn (fn [${1:arg-list}] $0) for Insert for (for [${1:item} ${2:coll}]\\n $0) if Insert if (if ${1:test-expr}\\n ${2:then-expr}\\n ${3:else-expr}) kwargs Insert keyword args {:keys [${1:keys}] :or {${2:defaults}}} let Insert let (let [$0]) letfn Insert letfn (letfn [(${1:name} [${2:args}]\\n $0)]) ns Insert ns (ns ${1:name}\\n $0:references}) ns-doc Insert ns with docstring (ns ${1:name}\\n \\\"${2:docstring}\\\"\\n ${0:references}) require Insert ns :require (:require [${1:namespace}])$0 require-as Insert ns require with :as alias (:require [${1:namespace} :as ${2:alias}]$3) require-refer Insert ns :require with :refer (:require [${1:namespace} :refer [$2]]$3) require-rdd Insert require for rich comment experiments (require '[${1:namespace} :as ${2:alias}]$3)$0 req-as Insert single require dep :as alias [${1:namespace} :as ${2:alias}] req-refer Insert single require dep with :refer [${1:namespace} :refer [$2]] import Insert import (:import [${1:package}]) use Insert require refer preferred over use (:require [${1:namespace} :refer [$2]]) deps-alias Insert alias with extra path & deps :${1:category/name}\\n {:extra-paths [\\\"${2:path}\\\"]\\n :extra-deps {${3:deps-maven or deps-git}}}$0 deps-maven Insert maven dependency ${1:domain/library-name} {:mvn/version \\\"${2:1.0.0}\\\"}$0 deps-git Insert git dependency ${1:domain/library-name}\\n {:git/sha \\\"${2:git-sha-value}\\\"}$0 deps-git-tag Insert git tag dependency ${1:domain/library-name}\\n {:git/tag \\\"${2:git-tag-value}\\\"\\n :git/sha \\\"${3:git-sha-value}\\\"}$0 deps-git-url Insert git URL dependency ${1:domain/library-name}\\n {:git/url \\\"https://github.com/$1\\\"\\n :git/sha \\\"${2:git-sha-value}\\\"}$0 deps-local Insert local dependency ${1:domain/library-name} {:local/root \\\"${2:/path/to/project/root}\\\"}$0 deftest Insert deftest clojure.test (deftest ${1:name}-test\\n (testing \\\"${2:Context of the test assertions}\\\"\\n (is (= ${3:assertion-values}))$4)) $0 testing Insert testing clojure.test (testing \\\"${1:Context of the test assertions}\\\"\\n $0) is Insert is clojure.test (is (= ${1:assertion-values}))","title":"Snippets"},{"location":"features/#custom-snippets","text":"User can register additional custom snippets, for more information on how to configure it, check the snippets settings section .","title":"Custom snippets"},{"location":"features/#code-actions","text":"See below for screenshots.","title":"Code actions"},{"location":"features/#code-lenses-showing-symbol-references","text":"","title":"Code lenses showing symbol references"},{"location":"features/#format-a-whole-file-or-range","text":"","title":"Format a whole file or range"},{"location":"features/#signature-help","text":"","title":"Signature help"},{"location":"features/#semantic-tokens","text":"The LSP server is the best to say what is the semantic value of a token on the editor, semantic tokens allows server return to client all tokens of a buffer and how client show apply highlight. Note: server return the semantic token (e.g. function ) and the client/editor apply the color that matches the user's theme.","title":"Semantic tokens"},{"location":"features/#call-hierarchy","text":"Show the incoming or outgoing call hierarchy of a function/variable as a lazy tree","title":"Call hierarchy"},{"location":"features/#incoming","text":"Show functions that call the current one recursively","title":"Incoming"},{"location":"features/#outgoing","text":"Show functions that the current one call, recursively","title":"Outgoing"},{"location":"features/#test-tree","text":"Show the tests tree hierarchy of a file","title":"Test Tree"},{"location":"features/#diagnostics-linter","text":"All linters besides the ones below come from clj-kondo that clojure-lsp calls under the hood to lint the code and retrieve the analysis to make most of features work. Every linter configuration should be done on clj-kondo side, so anything related to unresolved symbols or unknown macros are probably related to wrong clj-kondo for the project. For more information on how to configure clj-kondo check here . Below you can find the custom linters implemented on clojure-lsp side that uses the :custom-lint-fn from clj-kondo:","title":"Diagnostics (linter)"},{"location":"features/#clojure-lspunused-public-var","text":"For more information on how to configure it, check the diagnostics settings section .","title":"clojure-lsp/unused-public-var"},{"location":"features/#stub-generation","text":"It's possible to configure clojure-lsp to generate and analyze stubs for specific namespaces available on your project classpath, this is useful for closed source dependencies like datomic.api , with that clojure-lsp will be able to make most features work with those dependencies. For more information check the stubs settings section .","title":"Stub generation"},{"location":"features/#execute-command","text":"Commands that client can request. Most code actions use these commands as actions.","title":"Execute command"},{"location":"features/#clojure-lsp-extra-commands","text":"Note: Most of these are available via code actions and clients or users may choose to use the code action menu to execute them instead of mapping. All functions in clojure-lsp have a two-letter mnemonic shortcut. E.g. tf for thread-first-all . We strongly suggest that client authors and users use these shortcuts keys when choosing to map these commands to key chords or menus; this allows for users to maintain muscle memory and familiarity as they switch between clients and editors. Thank you to clj-refactor for this system and other tools that adhere to it. LSP clients will allow you to bind these commands to shortcuts or menu items using LSP's workspace/executeCommand and passing a map with \"command\" and \"arguments\" keys. Arguments: - file-uri : Absolute file uri. e.x. file:///home/user/project/src/main.clj - row : line-number of the cursor, 0 based. - col : col-number of the cursor, 0 based. - name : Used when introducing a name, usually a string for a valid clojure symbol. - filename : Filename path. e.x. src/utils.clj Shortcut Command Name Arguments Available via code action Example ai add-import-to-namespace Add import to namespace [file-uri,row,col[,name]] \u2705 am add-missing-libspec Add missing require [file-uri,row,col] \u2705 as add-require-suggestion Add require suggestion [file-uri,row,col,ns,alias,refer] \u2705 cc cycle-coll Cycle collection (#{}, {}, [], ()) [file-uri,row,col] \u2705 cf cycle-fn-literal Cycle fn literal (fn []), #() [file-uri,row,col] \u2705 cn clean-ns Clean namespace [file-uri,row,col] \u2705 cp cycle-privacy Cycle privacy of def/defn [file-uri,row,col] \u2705 ct create-test Create test [file-uri,row,col] \u2705 db drag-backward Drag backward [file-uri,row,col] \u2705 df drag-forward Drag forward [file-uri,row,col] \u2705 ef extract-function Extract Function [file-uri,row,col,name] \u2705 el expand-let Expand let [file-uri,row,col] fe create-function Create function from example [file-uri,row,col] \u2705 il introduce-let Introduce let [file-uri,row,col,name] is inline-symbol Inline Symbol [file-uri,row,col] \u2705 ma resolve-macro-as Resolve macro as [file-uri,row,col] \u2705 mf move-form Move form [file-uri,row,col,filename] \u2705 ml move-to-let Move expression to let [file-uri,row,col,name] \u2705 sc change-collection Switch collection to {}, (), #{}, [] [file-uri,row,col,\"map\"/\"list\"/\"set\"/\"vector\"] \u2705 sm sort-map Sort map [file-uri,row,col] \u2705 tf thread-first-all Thread first all [file-uri,row,col] \u2705 th thread-first Thread first expression [file-uri,row,col] tl thread-last-all Thread last all [file-uri,row,col] \u2705 tt thread-last Thread last expression [file-uri,row,col] ua unwind-all Unwind all [file-uri,row,col] \u2705 uw unwind-thread Unwind thread [file-uri,row,col]","title":"clojure-lsp extra commands"},{"location":"features/#dev","text":"","title":"Dev"},{"location":"features/#server-information","text":"Return basic information about the server.","title":"Server information"},{"location":"features/#cursor-information","text":"Return debug information about the element at point.","title":"Cursor information"},{"location":"installation/","text":"Installation # Below are all available clojure-lsp installation methods, after installed, follow the documentation for your editor's language client. See Clients . Homebrew (MacOS and Linux) # We have a custom tap using the native compiled binaries for users that use homebrew: brew remove clojure-lsp # if you have old clojure-lsp installed via brew brew install clojure-lsp/brew/clojure-lsp-native Script # Stable release: sudo bash < < ( curl -s https://raw.githubusercontent.com/clojure-lsp/clojure-lsp/master/install ) nightly build: curl -O https://raw.githubusercontent.com/clojure-lsp/clojure-lsp/master/install chmod a+x install sudo ./install --version nightly Nix # clojure-lsp is available in the nixpkgs : nix-shell -p clojure-lsp Arch Linux # clojure-lsp is available in the Arch User Repository . It can be installed using your favorite AUR helper such as yay , yaourt , apacman and pacaur . Here is an example using yay : yay -S clojure-lsp-bin Windows # clojure-lsp is available as a native executable in the Clojure Scoop bucket . You need to install Scoop if you don't have it already. Issue following command to download the clojure-lsp executable. scoop install clojure-lsp Native binary (recommended) # clojure-lsp builds using GraalVM a native executable for each OS: Linux, MacOS and Windows. Manually # The binaries are available on Github releases as clojure-lsp-native-<os>-<arch>.zip , after downloading you just need to unzip it. Embedded jar (Legacy executable) # In Github releases you will find a clojure-lsp file that runs a embedded jar. This should be removed soon, use GraalVM binaries instead. You need java on your $PATH. Grab the latest clojure-lsp from github LATEST Place it in your $PATH with a chmod 755","title":"Installation"},{"location":"installation/#installation","text":"Below are all available clojure-lsp installation methods, after installed, follow the documentation for your editor's language client. See Clients .","title":"Installation"},{"location":"installation/#homebrew-macos-and-linux","text":"We have a custom tap using the native compiled binaries for users that use homebrew: brew remove clojure-lsp # if you have old clojure-lsp installed via brew brew install clojure-lsp/brew/clojure-lsp-native","title":"Homebrew (MacOS and Linux)"},{"location":"installation/#script","text":"Stable release: sudo bash < < ( curl -s https://raw.githubusercontent.com/clojure-lsp/clojure-lsp/master/install ) nightly build: curl -O https://raw.githubusercontent.com/clojure-lsp/clojure-lsp/master/install chmod a+x install sudo ./install --version nightly","title":"Script"},{"location":"installation/#nix","text":"clojure-lsp is available in the nixpkgs : nix-shell -p clojure-lsp","title":"Nix"},{"location":"installation/#arch-linux","text":"clojure-lsp is available in the Arch User Repository . It can be installed using your favorite AUR helper such as yay , yaourt , apacman and pacaur . Here is an example using yay : yay -S clojure-lsp-bin","title":"Arch Linux"},{"location":"installation/#windows","text":"clojure-lsp is available as a native executable in the Clojure Scoop bucket . You need to install Scoop if you don't have it already. Issue following command to download the clojure-lsp executable. scoop install clojure-lsp","title":"Windows"},{"location":"installation/#native-binary-recommended","text":"clojure-lsp builds using GraalVM a native executable for each OS: Linux, MacOS and Windows.","title":"Native binary (recommended)"},{"location":"installation/#manually","text":"The binaries are available on Github releases as clojure-lsp-native-<os>-<arch>.zip , after downloading you just need to unzip it.","title":"Manually"},{"location":"installation/#embedded-jar-legacy-executable","text":"In Github releases you will find a clojure-lsp file that runs a embedded jar. This should be removed soon, use GraalVM binaries instead. You need java on your $PATH. Grab the latest clojure-lsp from github LATEST Place it in your $PATH with a chmod 755","title":"Embedded jar (Legacy executable)"},{"location":"settings/","text":"Settings # clojure-lsp settings are picked up only on server start and can be configured in 4 ways: Project configuration Global configuration LSP InitializationOptions Classpath config paths Project # clojure-lsp will look for project specific settings in a file called .lsp/config.edn . It will search from your project root folder up the directory structure so you can have multiple projects share the same settings. Example: { :cljfmt { :indents { # re \".*\" ns [[ :inner 0 ] [ :inner 1 ]]}} :auto-add-ns-to-new-files? false } Global # For global settings which should work for all the projects using clojure-lsp , you just need to add the same configs to ~/.config/clojure-lsp/config.edn or $XDG_CONFIG_HOME/clojure-lsp/config.edn . Note: ~/.lsp/config.edn is considered too but deprecated. For an example of a global config.edn , check here . InitializationOptions # This is specific for a client, which it sends to clojure-lsp on startup, check LSP spec for more information . This is useful if you are changing a default for a client/editor that will affect all users of that editor. This is an example how Emacs lsp-mode pass custom information. Another example, for neovim users, using coc.nvim and coc-clojure can be found here If you are using a client which defines InitializationOptions as a json object, you can use json types instead: keyword -> string or colon-prefixed string ( \"incremental\" or \":incremental\" ) map -> object ( {\"unused-public-ns\": {\"level\": \"info\"}} ) set -> array ( [\"src\" \"test\"] ) vector -> array ( [\"src\" \"test\"] ) Classpath config paths # When starting the server, clojure-lsp will search for a specific path clojure-lsp.exports/<group-id>/<artifact-id>/config.edn for extra configurations in the classpath, only if you set the setting :classpath-config-paths containing that group/artifact . Example: Lib my-org/my-lib could have a clojure-lsp config edn that makes sense for the usages of that lib, making available on the classpath: my-lib/resources/clojure-lsp.exports/my-org/my-lib/config.edn { :cljfmt { :indents { foo [[ :block 0 ]]}}} and then if your project use/has the my-org/my-lib inside your classpath, you could add the setting your-project/.lsp/config.edn { :classpath-config-paths [ \"my-org/my-lib\" ]} And then clojure-lsp will merge the configuration from the lib with the other configurations from your project. This is useful if you have some rule to apply to clojure-lsp for multiple projects, mostly using via API for linting for example, and want to move the common configuration to some place instead of adding to each project that needs that. All settings # You can find all settings and its default values here and below the docs for each one: name description default :clean Settings related to clean-ns refactoring. Check Clean settings below. :additional-snippets Additional user snippets to be available during completing, check the snippets section below [] :api :exit-on-errors? Whether to exit the clojure-lsp process during api/cli call if any error is found, like classpath scan failure true :auto-add-ns-to-new-files? Whether to automatically add the ns form in new blank files. true :cache-path Where to store the project's analysis cache, used to speed up next clojure-lsp startup. A path relative to project root or an absolute path. .lsp/.cache :classpath-config-paths List of extra configurations to load from classpath, for more info, check Classpath config paths section. [] :cljfmt-config-path Where to find cljfmt configuration for formatting. A path relative to project root or an absolute path. Use #re for regex inside the cljfmt configuration file. .cljfmt.edn :cljfmt If no :cljfmt-config-path is provided, used this for formatting, json encoded configuration for cljfmt {} :code-lens :segregate-test-references Segregate main references from test references with option to disable true :copy-kondo-configs? Whether to copy clj-kondo hooks configs exported by libs on classpath during startup lint. true :dependency-scheme How the dependencies should be linked, jar will make urls compatible with java's JarURLConnection. You can have the client make an lsp extension request of clojure/dependencyContents with the jar uri and the server will return the jar entry's contents. Similar to java clients zip :document-formatting? if true or not present, document formatting is provided. true :document-range-formatting? if true or not present, document range formatting is provided. true :hover :arity-on-same-line? Whether to keep the arity on the same line of the function on hover, useful for Emacs users. false :hover :clojuredocs Whether to get clojuredocs information on hover, the clojuredocs content is cached. true :hover :hide-file-location? Whether to show the full filename and path on hover. false :ignore-classpath-directories will not consider clojure files within the directories specified by your classpath. This is needed, for instance, if your build puts artifacts into resources or target that you want lsp to ignore. false :java :download-jdk-source? Whether to download JDK source from :java :jdk-source-download-uri and cache after startup for JDK classes java support. false :java :jdk-source-uri URI containing the JDK source to be used. If :download-jdk-source? is enabled and URI is NOT file:// then download the source. Check https://github.com/clojure-lsp/jdk-source for more sources. https://raw.githubusercontent.com/clojure-lsp/jdk-source/main/openjdk-19/reduced/source.zip :keep-parens-when-threading? Whether to keep parenthesis when threading single arity functions. false :lint-project-files-after-startup? Whether to async lint all project only files after startup to make features like List project errors work. true :linters clojure-lsp custom linters, check the diagnostics settings section below :log-path A absolute path to a file where clojure-lsp should log. A JVM tmp path, usually /tmp/clojure-lsp.*.out :notify-references-on-file-change Whether to update diagnostics of the changed references when editing files, avoiding outdated diagnostics in other files. true :project-specs A vector of a map with :project-path and :classpath-cmd , defining how clojure-lsp should find your project classpath. The :project-path should be a file and the :classpath-cmd the command to run to get the classpath Check Classpath scan section below :semantic-tokens? Whether to enable LSP semantic tokens server support for syntax highlighting. true :source-aliases Used for deps.edn or project.clj projects, the aliases which clojure-lsp should get the source-paths besides the root level :paths and :extra-paths . Check the Source paths discovery section below. #{:dev :test} :source-paths project-local directories to look for clj/cljc/cljs files, if using deps.edn , project.clj or bb.edn , use :source-aliases instead. #{\"src\" \"test\"} :stubs Stub generation related settings, check the Stub generation section below. :text-document-sync-kind The sync kind during document changes, if client should send whole buffer or just related changes. Should be :full or :incremental :full :use-metadata-for-privacy? Whether to use ^:private metadata for refactorings instead of defn- false :use-source-paths-from-classpath Whether to check source-paths from classpath or manually discover true Classpath scan # clojure-lsp needs to analyze the whole project and its dependencies to understand your code for most features, during the startup clojure-lsp will try to find the classpath of your project to pass to clj-kondo later. You can configure how clojure-lsp should find the classpath with the project-specs setting, but keep in mind that usually the default is enough, it will also consider the :source-aliases setting if any to find the classpath using those aliases. Supported project types at the moment are: leiningen : If a project.clj is found at the project root, clojure-lsp will run lein classpath with :source-aliases specified if any. deps : If a deps.edn is found at the project root, clojure-lsp will run clojure -Spath with :source-aliases specified if any. boot : If a build.boot is found at the project root, clojure-lsp will run boot show --fake-classpath . shadow-cljs : If a shadow-cljs.edn is found at the project root, clojure-lsp will run npx shadow-cljs classpath . babashka : If a bb.edn is found at the project root, clojure-lsp will run bb print-deps --format classpath . Note that it's possible to have more and one project type at the same time e.g. deps + babashka, clojure-lsp will merge the classpath and everything should works fine. Make sure to have these programs available on the PATH environment variable used by your editor, otherwise clojure-lsp will warn about a classpath scan fail, causing a lot of features to not work properly. Alternatively, you can configure the project-specs specific for your project, for example: .lsp/config.edn { :project-specs [{ :project-path \"deps.edn\" :classpath-cmd [ \"clojure\" \"-A:my-custom-alias\" \"-Spath\" ]}]} Note that clojure-lsp will make this scan to save the cache when: The project has no cache ( .lsp/.cache ) The project deps file ( project.clj for example) changed. The clj-kondo config has changed. Diagnostics (linter) # Default: Check :linters in all-available-settings.edn . clj-kondo # clojure-lsp uses clj-kondo under the hood to lint the code and retrieve the analysis to make most of features work, you don't have to install clj-kondo to make it work. clojure-lsp will use a specific clj-kondo version that can be retrieved via clojure-lsp --version , but make sure you have it properly configured in your .clj-kondo/config.edn file. It has the possible key/values: :clj-kondo :level with available values: :off , :on with default value of :on :report-duplicates which will show all linters of the same symbol instead of showing only the first spot. Available values: true , false with default value of true ns-exclude-regex which will exclude the diagnostics/findings for namespaces that match this regex. async-custom-lint? , whether to async lint custom clojure-lsp linters like unused-public-var, improves UI feedback for huge clojure buffers. Experimental, default true . Example: .lsp/config.edn { :linters { :clj-kondo { :level :on :report-duplicates true :ns-exclude-regex \"some-ns.*\" }}} Note for vim users If you are a (neo)vim user and have [ale](https://github.com/dense-analysis/ale) installed as a plugin, you **should not** have this configured as a linter `let g:ale_linters = {'clojure': ['clj-kondo']}` in your vimrc. Having this linter enabled via `ale` will only conflict with the built-in clj-kondo bundled with clojure-lsp. Also, clojure-lsp by default pass copy-configs flag as true to clj-kondo to copy configurations exported from libs on classpath, to disable this behavior, set copy-kondo-configs? setting to false. For more information about all clj-kondo available configurations, check the clj-kondo configuration section Custom clj-kondo linters # Clojure-lsp register custom linters in clj-kondo, for specifically those linters, configurations should be done on clj-kondo config files, e.g. ( <project>/.clj-kondo/config.edn ), below are the custom linters used: clojure-lsp/unused-public-var # A custom linter that reports public functions/vars not used over the project. It has the possible key/values: :level with available values: :info , :warning , :error or :off with default value of :info . :exclude a whole namespace with #{my-ns} or a specific var #{my-ns/foo} . :exclude-when-defined-by excludes this linter when your var is defined by a macro for example, like #{my-ns/deftest} . Example: .clj-kondo/config.edn { :linters { :clojure-lsp/unused-public-var { :level :warning :exclude # { my-ns/foo my-ns/bar other-ns my-func } :exclude-regex # { \"my-integration-tests.*\" } :exclude-when-defined-by # { my-ns/defflow } :exclude-when-defined-by-regex # { \"my.custom/macro-.*\" }}}} Disable linter # It's not recommended to disable the linter as it provides helpful smart checks/suggestions for your code, even so it's possible via the following config: .lsp/config.edn { :linters { :clj-kondo { :level :off }}} For information on how to troubleshoot the linter, check the troubleshooting section Source paths discovery # Some features require know the available source paths of your project, where your code lives, clojure-lsp has some settings for that. When :use-source-paths-from-classpath setting is enabled (which is true by default), clojure-lsp will get source-paths from the classpath, excluding files that are jar and not under project-root, this usually works for most cases, if not, check :source-aliases or :source-paths settings. If :use-source-paths-from-classpath is manually disabled, clojure-lsp will do the following: If your project is a lein project, clojure-lsp will scan the project.clj file for :source-paths , :test-paths and the optional source-paths from the specified :source-aliases setting (default #{:dev :test} ), unless you specified :source-paths setting manually. If your project is a deps.edn , clojure-lsp will scan the deps.edn file for :paths , :extra-paths , :local/root on :deps , :extra-deps and the paths , extra-paths , :local/root in :deps and :extra-deps from the specified :source-aliases setting (default #{:dev :test} ), unless you specified :source-paths setting manually. If your project is not a deps.edn or lein project, a boot project for example, clojure-lsp will use only the :source-paths setting (default #{\"src\" \"test\"} ) which should point to the folders containing your clojure code. Clean # Default: Check :clean in all-available-settings.edn . after-ns-refactor # Whether to call clean-ns on the namespace after applying any refactor to it like adding missing require/imports/refers. ns-inner-blocks-indentation # How to indent ns children forms like require,import. next-line # Keep first child on the next line of :require / :import and next children following the same indentation. Recommended by how-to-ns guide too. Check ;; better on Clojure Style Guide . same-line # Keep first child on the same line of :require / :import and next children following the same indentation. Check ;; good on Clojure Style Guide . keep # Don't change indentation at all, keeping the one user selected first. sort # ns # Whether to enable sort of ns children like require, import forms following Clojure Style Guide . require # Whether to enable sort of :require form. true to sort according to the Clojure Style Guide, :lexicographically to do a lexicographic sort that places unwrapped namespaces last. import # Whether to enable sort of :import form. refer # Whether to enable sort of :refer form. :max-line-length : the max refers to keep at same line before breaking the line. Default 80 . Snippets # Besides the 19 built-in snippets, it's possible to configure custom additional snippets via :additional-snippets setting: :name the name to use while completing to reach that snippet. :detail Custom text to show along with the completion name. :snippet The body of the snippet, besides any text it can contains: $1 , $2 , ... as the tabstops representing each place where user may change the content. $0 as the last tabstop. $current-form to replace the current form in the snippet. Example: { :additional-snippets [{ :name \"wrap-let-sexpr\" :detail \"Wrap current sexpr in let\" :snippet \"(let [$1] $0$current-form)\" }]} when completion is called on the code below with the cursor as | wrap| ( + 1 2 ) It should return a completion item that after applied should result in: ( let [ | ] ( + 1 2 )) Java support # At the moment, clojure-lsp supports find definition of java classes only, methods, completion and other features are not supported yet. When a find-definition of a java class is triggered, clojure-lsp checks the following: If the java source( .java ) is available on classpath, clojure-lsp just return that file location. If the java source is not available, only the .class , clojure-lsp decompiles it and save the generated .java in a cache folder ( .lsp/.cache/java/ ) If the java class is from JDK (e.g. java.util.UUID ), clojure-lsp tries a few things to be able to sucessfully find the definition, following this waterfall decision: Most JRE installations contains the java source code in a src.zip , clojure-lsp tries to find it via JAVA_HOME or java command on PATH , if found clojure-lsp extracts to its global cache config (XDG_CONFIG or ~/.config/clojure-lsp ) to be used in other projects. If src.zip is not found or user specified a custom :java :jdk-source-uri , clojure-lsp tries to download the source from that uri, only if :java :download-jdk-source? is enabled, disabled by default, extracting to the global cache dir later. Stub generation # It's possible to configure clojure-lsp to generate and analyze stubs for specific namespaces available on your project classpath, this is useful for closed source dependencies like datomic.api , with that clojure-lsp will be able to make most features work with those dependencies. The available settings inside :stubs are: :generation for auto stubs generation: :namespaces the namespaces to generate and analyze stubs, empty by default disabling stub generation. :output-dir the output where to generate the stubs, by default .lsp/.cache/stubs :java-command the path to java command to spawn the stub process, default use java from $PATH . :extra-dirs , dirs to analyze to consider as part of manual generated stubs. Empty by default. Example: { :stubs { :generation { :namespaces # { \"datomic.api\" }}}} This should generate stubs for datomic.api namespace only on .lsp/.cache/stubs and clojure-lsp should analyze that during startup to provide completion, hover and other features. Or to use manual generated stubs: { :stubs { :extra-dirs [ \".my-stubs\" ]}} clojure-lsp will generate no stubs with that, but analyze that folder and consider it as manual generated stubs.","title":"Settings"},{"location":"settings/#settings","text":"clojure-lsp settings are picked up only on server start and can be configured in 4 ways: Project configuration Global configuration LSP InitializationOptions Classpath config paths","title":"Settings"},{"location":"settings/#project","text":"clojure-lsp will look for project specific settings in a file called .lsp/config.edn . It will search from your project root folder up the directory structure so you can have multiple projects share the same settings. Example: { :cljfmt { :indents { # re \".*\" ns [[ :inner 0 ] [ :inner 1 ]]}} :auto-add-ns-to-new-files? false }","title":"Project"},{"location":"settings/#global","text":"For global settings which should work for all the projects using clojure-lsp , you just need to add the same configs to ~/.config/clojure-lsp/config.edn or $XDG_CONFIG_HOME/clojure-lsp/config.edn . Note: ~/.lsp/config.edn is considered too but deprecated. For an example of a global config.edn , check here .","title":"Global"},{"location":"settings/#initializationoptions","text":"This is specific for a client, which it sends to clojure-lsp on startup, check LSP spec for more information . This is useful if you are changing a default for a client/editor that will affect all users of that editor. This is an example how Emacs lsp-mode pass custom information. Another example, for neovim users, using coc.nvim and coc-clojure can be found here If you are using a client which defines InitializationOptions as a json object, you can use json types instead: keyword -> string or colon-prefixed string ( \"incremental\" or \":incremental\" ) map -> object ( {\"unused-public-ns\": {\"level\": \"info\"}} ) set -> array ( [\"src\" \"test\"] ) vector -> array ( [\"src\" \"test\"] )","title":"InitializationOptions"},{"location":"settings/#classpath-config-paths","text":"When starting the server, clojure-lsp will search for a specific path clojure-lsp.exports/<group-id>/<artifact-id>/config.edn for extra configurations in the classpath, only if you set the setting :classpath-config-paths containing that group/artifact . Example: Lib my-org/my-lib could have a clojure-lsp config edn that makes sense for the usages of that lib, making available on the classpath: my-lib/resources/clojure-lsp.exports/my-org/my-lib/config.edn { :cljfmt { :indents { foo [[ :block 0 ]]}}} and then if your project use/has the my-org/my-lib inside your classpath, you could add the setting your-project/.lsp/config.edn { :classpath-config-paths [ \"my-org/my-lib\" ]} And then clojure-lsp will merge the configuration from the lib with the other configurations from your project. This is useful if you have some rule to apply to clojure-lsp for multiple projects, mostly using via API for linting for example, and want to move the common configuration to some place instead of adding to each project that needs that.","title":"Classpath config paths"},{"location":"settings/#all-settings","text":"You can find all settings and its default values here and below the docs for each one: name description default :clean Settings related to clean-ns refactoring. Check Clean settings below. :additional-snippets Additional user snippets to be available during completing, check the snippets section below [] :api :exit-on-errors? Whether to exit the clojure-lsp process during api/cli call if any error is found, like classpath scan failure true :auto-add-ns-to-new-files? Whether to automatically add the ns form in new blank files. true :cache-path Where to store the project's analysis cache, used to speed up next clojure-lsp startup. A path relative to project root or an absolute path. .lsp/.cache :classpath-config-paths List of extra configurations to load from classpath, for more info, check Classpath config paths section. [] :cljfmt-config-path Where to find cljfmt configuration for formatting. A path relative to project root or an absolute path. Use #re for regex inside the cljfmt configuration file. .cljfmt.edn :cljfmt If no :cljfmt-config-path is provided, used this for formatting, json encoded configuration for cljfmt {} :code-lens :segregate-test-references Segregate main references from test references with option to disable true :copy-kondo-configs? Whether to copy clj-kondo hooks configs exported by libs on classpath during startup lint. true :dependency-scheme How the dependencies should be linked, jar will make urls compatible with java's JarURLConnection. You can have the client make an lsp extension request of clojure/dependencyContents with the jar uri and the server will return the jar entry's contents. Similar to java clients zip :document-formatting? if true or not present, document formatting is provided. true :document-range-formatting? if true or not present, document range formatting is provided. true :hover :arity-on-same-line? Whether to keep the arity on the same line of the function on hover, useful for Emacs users. false :hover :clojuredocs Whether to get clojuredocs information on hover, the clojuredocs content is cached. true :hover :hide-file-location? Whether to show the full filename and path on hover. false :ignore-classpath-directories will not consider clojure files within the directories specified by your classpath. This is needed, for instance, if your build puts artifacts into resources or target that you want lsp to ignore. false :java :download-jdk-source? Whether to download JDK source from :java :jdk-source-download-uri and cache after startup for JDK classes java support. false :java :jdk-source-uri URI containing the JDK source to be used. If :download-jdk-source? is enabled and URI is NOT file:// then download the source. Check https://github.com/clojure-lsp/jdk-source for more sources. https://raw.githubusercontent.com/clojure-lsp/jdk-source/main/openjdk-19/reduced/source.zip :keep-parens-when-threading? Whether to keep parenthesis when threading single arity functions. false :lint-project-files-after-startup? Whether to async lint all project only files after startup to make features like List project errors work. true :linters clojure-lsp custom linters, check the diagnostics settings section below :log-path A absolute path to a file where clojure-lsp should log. A JVM tmp path, usually /tmp/clojure-lsp.*.out :notify-references-on-file-change Whether to update diagnostics of the changed references when editing files, avoiding outdated diagnostics in other files. true :project-specs A vector of a map with :project-path and :classpath-cmd , defining how clojure-lsp should find your project classpath. The :project-path should be a file and the :classpath-cmd the command to run to get the classpath Check Classpath scan section below :semantic-tokens? Whether to enable LSP semantic tokens server support for syntax highlighting. true :source-aliases Used for deps.edn or project.clj projects, the aliases which clojure-lsp should get the source-paths besides the root level :paths and :extra-paths . Check the Source paths discovery section below. #{:dev :test} :source-paths project-local directories to look for clj/cljc/cljs files, if using deps.edn , project.clj or bb.edn , use :source-aliases instead. #{\"src\" \"test\"} :stubs Stub generation related settings, check the Stub generation section below. :text-document-sync-kind The sync kind during document changes, if client should send whole buffer or just related changes. Should be :full or :incremental :full :use-metadata-for-privacy? Whether to use ^:private metadata for refactorings instead of defn- false :use-source-paths-from-classpath Whether to check source-paths from classpath or manually discover true","title":"All settings"},{"location":"settings/#classpath-scan","text":"clojure-lsp needs to analyze the whole project and its dependencies to understand your code for most features, during the startup clojure-lsp will try to find the classpath of your project to pass to clj-kondo later. You can configure how clojure-lsp should find the classpath with the project-specs setting, but keep in mind that usually the default is enough, it will also consider the :source-aliases setting if any to find the classpath using those aliases. Supported project types at the moment are: leiningen : If a project.clj is found at the project root, clojure-lsp will run lein classpath with :source-aliases specified if any. deps : If a deps.edn is found at the project root, clojure-lsp will run clojure -Spath with :source-aliases specified if any. boot : If a build.boot is found at the project root, clojure-lsp will run boot show --fake-classpath . shadow-cljs : If a shadow-cljs.edn is found at the project root, clojure-lsp will run npx shadow-cljs classpath . babashka : If a bb.edn is found at the project root, clojure-lsp will run bb print-deps --format classpath . Note that it's possible to have more and one project type at the same time e.g. deps + babashka, clojure-lsp will merge the classpath and everything should works fine. Make sure to have these programs available on the PATH environment variable used by your editor, otherwise clojure-lsp will warn about a classpath scan fail, causing a lot of features to not work properly. Alternatively, you can configure the project-specs specific for your project, for example: .lsp/config.edn { :project-specs [{ :project-path \"deps.edn\" :classpath-cmd [ \"clojure\" \"-A:my-custom-alias\" \"-Spath\" ]}]} Note that clojure-lsp will make this scan to save the cache when: The project has no cache ( .lsp/.cache ) The project deps file ( project.clj for example) changed. The clj-kondo config has changed.","title":"Classpath scan"},{"location":"settings/#diagnostics-linter","text":"Default: Check :linters in all-available-settings.edn .","title":"Diagnostics (linter)"},{"location":"settings/#clj-kondo","text":"clojure-lsp uses clj-kondo under the hood to lint the code and retrieve the analysis to make most of features work, you don't have to install clj-kondo to make it work. clojure-lsp will use a specific clj-kondo version that can be retrieved via clojure-lsp --version , but make sure you have it properly configured in your .clj-kondo/config.edn file. It has the possible key/values: :clj-kondo :level with available values: :off , :on with default value of :on :report-duplicates which will show all linters of the same symbol instead of showing only the first spot. Available values: true , false with default value of true ns-exclude-regex which will exclude the diagnostics/findings for namespaces that match this regex. async-custom-lint? , whether to async lint custom clojure-lsp linters like unused-public-var, improves UI feedback for huge clojure buffers. Experimental, default true . Example: .lsp/config.edn { :linters { :clj-kondo { :level :on :report-duplicates true :ns-exclude-regex \"some-ns.*\" }}} Note for vim users If you are a (neo)vim user and have [ale](https://github.com/dense-analysis/ale) installed as a plugin, you **should not** have this configured as a linter `let g:ale_linters = {'clojure': ['clj-kondo']}` in your vimrc. Having this linter enabled via `ale` will only conflict with the built-in clj-kondo bundled with clojure-lsp. Also, clojure-lsp by default pass copy-configs flag as true to clj-kondo to copy configurations exported from libs on classpath, to disable this behavior, set copy-kondo-configs? setting to false. For more information about all clj-kondo available configurations, check the clj-kondo configuration section","title":"clj-kondo"},{"location":"settings/#custom-clj-kondo-linters","text":"Clojure-lsp register custom linters in clj-kondo, for specifically those linters, configurations should be done on clj-kondo config files, e.g. ( <project>/.clj-kondo/config.edn ), below are the custom linters used:","title":"Custom clj-kondo linters"},{"location":"settings/#clojure-lspunused-public-var","text":"A custom linter that reports public functions/vars not used over the project. It has the possible key/values: :level with available values: :info , :warning , :error or :off with default value of :info . :exclude a whole namespace with #{my-ns} or a specific var #{my-ns/foo} . :exclude-when-defined-by excludes this linter when your var is defined by a macro for example, like #{my-ns/deftest} . Example: .clj-kondo/config.edn { :linters { :clojure-lsp/unused-public-var { :level :warning :exclude # { my-ns/foo my-ns/bar other-ns my-func } :exclude-regex # { \"my-integration-tests.*\" } :exclude-when-defined-by # { my-ns/defflow } :exclude-when-defined-by-regex # { \"my.custom/macro-.*\" }}}}","title":"clojure-lsp/unused-public-var"},{"location":"settings/#disable-linter","text":"It's not recommended to disable the linter as it provides helpful smart checks/suggestions for your code, even so it's possible via the following config: .lsp/config.edn { :linters { :clj-kondo { :level :off }}} For information on how to troubleshoot the linter, check the troubleshooting section","title":"Disable linter"},{"location":"settings/#source-paths-discovery","text":"Some features require know the available source paths of your project, where your code lives, clojure-lsp has some settings for that. When :use-source-paths-from-classpath setting is enabled (which is true by default), clojure-lsp will get source-paths from the classpath, excluding files that are jar and not under project-root, this usually works for most cases, if not, check :source-aliases or :source-paths settings. If :use-source-paths-from-classpath is manually disabled, clojure-lsp will do the following: If your project is a lein project, clojure-lsp will scan the project.clj file for :source-paths , :test-paths and the optional source-paths from the specified :source-aliases setting (default #{:dev :test} ), unless you specified :source-paths setting manually. If your project is a deps.edn , clojure-lsp will scan the deps.edn file for :paths , :extra-paths , :local/root on :deps , :extra-deps and the paths , extra-paths , :local/root in :deps and :extra-deps from the specified :source-aliases setting (default #{:dev :test} ), unless you specified :source-paths setting manually. If your project is not a deps.edn or lein project, a boot project for example, clojure-lsp will use only the :source-paths setting (default #{\"src\" \"test\"} ) which should point to the folders containing your clojure code.","title":"Source paths discovery"},{"location":"settings/#clean","text":"Default: Check :clean in all-available-settings.edn .","title":"Clean"},{"location":"settings/#after-ns-refactor","text":"Whether to call clean-ns on the namespace after applying any refactor to it like adding missing require/imports/refers.","title":"after-ns-refactor"},{"location":"settings/#ns-inner-blocks-indentation","text":"How to indent ns children forms like require,import.","title":"ns-inner-blocks-indentation"},{"location":"settings/#next-line","text":"Keep first child on the next line of :require / :import and next children following the same indentation. Recommended by how-to-ns guide too. Check ;; better on Clojure Style Guide .","title":"next-line"},{"location":"settings/#same-line","text":"Keep first child on the same line of :require / :import and next children following the same indentation. Check ;; good on Clojure Style Guide .","title":"same-line"},{"location":"settings/#keep","text":"Don't change indentation at all, keeping the one user selected first.","title":"keep"},{"location":"settings/#sort","text":"","title":"sort"},{"location":"settings/#ns","text":"Whether to enable sort of ns children like require, import forms following Clojure Style Guide .","title":"ns"},{"location":"settings/#require","text":"Whether to enable sort of :require form. true to sort according to the Clojure Style Guide, :lexicographically to do a lexicographic sort that places unwrapped namespaces last.","title":"require"},{"location":"settings/#import","text":"Whether to enable sort of :import form.","title":"import"},{"location":"settings/#refer","text":"Whether to enable sort of :refer form. :max-line-length : the max refers to keep at same line before breaking the line. Default 80 .","title":"refer"},{"location":"settings/#snippets","text":"Besides the 19 built-in snippets, it's possible to configure custom additional snippets via :additional-snippets setting: :name the name to use while completing to reach that snippet. :detail Custom text to show along with the completion name. :snippet The body of the snippet, besides any text it can contains: $1 , $2 , ... as the tabstops representing each place where user may change the content. $0 as the last tabstop. $current-form to replace the current form in the snippet. Example: { :additional-snippets [{ :name \"wrap-let-sexpr\" :detail \"Wrap current sexpr in let\" :snippet \"(let [$1] $0$current-form)\" }]} when completion is called on the code below with the cursor as | wrap| ( + 1 2 ) It should return a completion item that after applied should result in: ( let [ | ] ( + 1 2 ))","title":"Snippets"},{"location":"settings/#java-support","text":"At the moment, clojure-lsp supports find definition of java classes only, methods, completion and other features are not supported yet. When a find-definition of a java class is triggered, clojure-lsp checks the following: If the java source( .java ) is available on classpath, clojure-lsp just return that file location. If the java source is not available, only the .class , clojure-lsp decompiles it and save the generated .java in a cache folder ( .lsp/.cache/java/ ) If the java class is from JDK (e.g. java.util.UUID ), clojure-lsp tries a few things to be able to sucessfully find the definition, following this waterfall decision: Most JRE installations contains the java source code in a src.zip , clojure-lsp tries to find it via JAVA_HOME or java command on PATH , if found clojure-lsp extracts to its global cache config (XDG_CONFIG or ~/.config/clojure-lsp ) to be used in other projects. If src.zip is not found or user specified a custom :java :jdk-source-uri , clojure-lsp tries to download the source from that uri, only if :java :download-jdk-source? is enabled, disabled by default, extracting to the global cache dir later.","title":"Java support"},{"location":"settings/#stub-generation","text":"It's possible to configure clojure-lsp to generate and analyze stubs for specific namespaces available on your project classpath, this is useful for closed source dependencies like datomic.api , with that clojure-lsp will be able to make most features work with those dependencies. The available settings inside :stubs are: :generation for auto stubs generation: :namespaces the namespaces to generate and analyze stubs, empty by default disabling stub generation. :output-dir the output where to generate the stubs, by default .lsp/.cache/stubs :java-command the path to java command to spawn the stub process, default use java from $PATH . :extra-dirs , dirs to analyze to consider as part of manual generated stubs. Empty by default. Example: { :stubs { :generation { :namespaces # { \"datomic.api\" }}}} This should generate stubs for datomic.api namespace only on .lsp/.cache/stubs and clojure-lsp should analyze that during startup to provide completion, hover and other features. Or to use manual generated stubs: { :stubs { :extra-dirs [ \".my-stubs\" ]}} clojure-lsp will generate no stubs with that, but analyze that folder and consider it as manual generated stubs.","title":"Stub generation"},{"location":"troubleshooting/","text":"Troubleshooting # Server log # clojure-lsp logs most of what is doing to a file which location could be found: on :log-path if specified in your clojure-lsp config, for example: {:log-path \"/tmp/clojure-lsp.out\"} Auto generated every server start on /tmp/clojure-lsp.<TIMESTAMP>.out Client<->Server log # All LSP clients should provide a way to get the jsonrpc logs between client and server, this helps debug the requests and responses content and time. Check below how to get the logs for most used clients: Emacs/lsp-mode VSCode/Calva Server is not initializing # Make sure you have the most recent version of clojure-lsp Check if the executable is working running it from the command line, it should start up and start reading from stdin. Type {}\\n\\n and you should get something like: $ clojure-lsp {} Apr 12, 2019 7:07:02 AM org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer fireError SEVERE: Missing header Content-Length in input \"{} \" java.lang.IllegalStateException: Missing header Content-Length in input \"{}\"\"\"\" \"\"\" If that is ok, clojure-lsp logs to /tmp/clojure-lsp.*.out , so watch that file and start your editor. LSP Clients also generally have a way to trace server interactions. Turn that on and attach both server and client logs to an issue if it's not obvious what's going on. For example, if you are using neovim with CoC , first ensure that trace.server is set to verbose in your coc-settings.json file, e.g., \"languageserver\" : { \"clojure-lsp\" : { \"command\" : \"clojure-lsp\" , \"filetypes\" : [ \"clojure\" ], \"disableDiagnostics\" : false , \"rootPatterns\" : [ \"deps.edn\" , \"project.clj\" ], \"additionalSchemes\" : [ \"jar\" , \"zipfile\" ], \"trace.server\" : \"verbose\" , \"initializationOptions\" : { \"project-specs\" : [{ \"project-path\" : \"deps.edn\" , \"classpath-cmd\" : [ \"clj\" , \"-Spath\" ] }], \"use-metadata-for-privacy?\" : true , \"ignore-classpath-directories\" : true } } } Then, once vim has loaded (and clojure-lsp has initialised), you can issue this command: :CocCommand workspace.showOutput This will show the JSON request/response bodies that go between vim and clojure-lsp. Please capture that information if you need help in tracking down the problem you are experiencing (either by reporting github issues, or talking with someone in Slack/Discord or whatever...) Some features are not working # clojure-lsp uses clj-kondo to scan the classpath during server initialize for most features work, so make sure you don't see any \"Error while looking up classpath...\" on clojure-lsp log file. Please note that clojure-lsp comes bundled with clj-kondo , so you do not have to install it separately. For more information, check the Classpath scan settings section. Classpath scan error # By default clojure-lsp knows how to scan most common clojure projects using the following rules: If the project root has a project.clj file, it'll run lein classpath to get the classpath. If the project root has a deps.edn file, it'll run clojure -Spath to get the classpath. If the project root has a build.boot file, it'll run boot show --fake-classpath to get the classpath. If the project root has a shadow-cljs.edn file, it'll run npx shadow-cljs classpath to get the classpath. If your project doesn't follow the above rules or you need a custom command to get the classpath you need to configure the project-specs clojure-lsp setting, for more details check the settings section . Folders not being analyzed # By default clojure-lsp searches src and test for clj* files to read into an index. If the definition lives under a different source dir, you can define the source-paths setting, for more details check the settings section . It is also important to get your project-root correct in your client otherwise the source paths will not be found, check the project-root via your LSP client. If you are using deps and using a :local/root dependency to reference another project, i.e., { :deps { foo.bar/baz { :local/root \"/path/to/foo/project/containing/a/deps.edn\" }}} and you are finding that gotoDefinition isn't working when attempting to jump to the namespace in the referenced project, then it could be that your ~/.lsp/config.edn (or ~/.config/clojure-lsp/config.edn ) has a source paths entry, i.e., :source-paths [\"src\" \"test\"] . This will prevent the lookup from working, as it restricts clojure-lsp to only scan those folders in the current project for sources, and not the other project referenced via the :local/root deps entry. It can be fixed by removing the :source-paths from the config (as clojure-lsp has good defaults anyway). If you do require more specific source paths, then those can be added at the project level. Wrong diagnostics/lint # clojure-lsp persist the external jars analysis in a .lsp/sqlite.db file, if you have issues with some specific feature, try to remove that file and restart the server. clojure-lsp use clj-kondo to lint and cache in a .clj-kondo/.cache dir, try to remove that file as well if you think it's not linting correctly If you have issues with macros, double check your clj-kondo config . Missing Add require... on code actions when using CoC and (neo)vim # If you find, when executing the command (coc-codeaction-line) (or (coc-codeaction-selected) or (coc-codeaction-cursor) ), that you aren't getting back all of the code actions you might expect, please ensure that you have, in your coc-settings.json the line disableDiagnostics set to false or better yet, don't have the line there at all :-) MacOS # In some version of MacOS, Apple restrict the binary to run, to fix that run: xattr -d com.apple.quarantine /path/to/clojure-lsp","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#server-log","text":"clojure-lsp logs most of what is doing to a file which location could be found: on :log-path if specified in your clojure-lsp config, for example: {:log-path \"/tmp/clojure-lsp.out\"} Auto generated every server start on /tmp/clojure-lsp.<TIMESTAMP>.out","title":"Server log"},{"location":"troubleshooting/#client-server-log","text":"All LSP clients should provide a way to get the jsonrpc logs between client and server, this helps debug the requests and responses content and time. Check below how to get the logs for most used clients: Emacs/lsp-mode VSCode/Calva","title":"Client&lt;-&gt;Server log"},{"location":"troubleshooting/#server-is-not-initializing","text":"Make sure you have the most recent version of clojure-lsp Check if the executable is working running it from the command line, it should start up and start reading from stdin. Type {}\\n\\n and you should get something like: $ clojure-lsp {} Apr 12, 2019 7:07:02 AM org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer fireError SEVERE: Missing header Content-Length in input \"{} \" java.lang.IllegalStateException: Missing header Content-Length in input \"{}\"\"\"\" \"\"\" If that is ok, clojure-lsp logs to /tmp/clojure-lsp.*.out , so watch that file and start your editor. LSP Clients also generally have a way to trace server interactions. Turn that on and attach both server and client logs to an issue if it's not obvious what's going on. For example, if you are using neovim with CoC , first ensure that trace.server is set to verbose in your coc-settings.json file, e.g., \"languageserver\" : { \"clojure-lsp\" : { \"command\" : \"clojure-lsp\" , \"filetypes\" : [ \"clojure\" ], \"disableDiagnostics\" : false , \"rootPatterns\" : [ \"deps.edn\" , \"project.clj\" ], \"additionalSchemes\" : [ \"jar\" , \"zipfile\" ], \"trace.server\" : \"verbose\" , \"initializationOptions\" : { \"project-specs\" : [{ \"project-path\" : \"deps.edn\" , \"classpath-cmd\" : [ \"clj\" , \"-Spath\" ] }], \"use-metadata-for-privacy?\" : true , \"ignore-classpath-directories\" : true } } } Then, once vim has loaded (and clojure-lsp has initialised), you can issue this command: :CocCommand workspace.showOutput This will show the JSON request/response bodies that go between vim and clojure-lsp. Please capture that information if you need help in tracking down the problem you are experiencing (either by reporting github issues, or talking with someone in Slack/Discord or whatever...)","title":"Server is not initializing"},{"location":"troubleshooting/#some-features-are-not-working","text":"clojure-lsp uses clj-kondo to scan the classpath during server initialize for most features work, so make sure you don't see any \"Error while looking up classpath...\" on clojure-lsp log file. Please note that clojure-lsp comes bundled with clj-kondo , so you do not have to install it separately. For more information, check the Classpath scan settings section.","title":"Some features are not working"},{"location":"troubleshooting/#classpath-scan-error","text":"By default clojure-lsp knows how to scan most common clojure projects using the following rules: If the project root has a project.clj file, it'll run lein classpath to get the classpath. If the project root has a deps.edn file, it'll run clojure -Spath to get the classpath. If the project root has a build.boot file, it'll run boot show --fake-classpath to get the classpath. If the project root has a shadow-cljs.edn file, it'll run npx shadow-cljs classpath to get the classpath. If your project doesn't follow the above rules or you need a custom command to get the classpath you need to configure the project-specs clojure-lsp setting, for more details check the settings section .","title":"Classpath scan error"},{"location":"troubleshooting/#folders-not-being-analyzed","text":"By default clojure-lsp searches src and test for clj* files to read into an index. If the definition lives under a different source dir, you can define the source-paths setting, for more details check the settings section . It is also important to get your project-root correct in your client otherwise the source paths will not be found, check the project-root via your LSP client. If you are using deps and using a :local/root dependency to reference another project, i.e., { :deps { foo.bar/baz { :local/root \"/path/to/foo/project/containing/a/deps.edn\" }}} and you are finding that gotoDefinition isn't working when attempting to jump to the namespace in the referenced project, then it could be that your ~/.lsp/config.edn (or ~/.config/clojure-lsp/config.edn ) has a source paths entry, i.e., :source-paths [\"src\" \"test\"] . This will prevent the lookup from working, as it restricts clojure-lsp to only scan those folders in the current project for sources, and not the other project referenced via the :local/root deps entry. It can be fixed by removing the :source-paths from the config (as clojure-lsp has good defaults anyway). If you do require more specific source paths, then those can be added at the project level.","title":"Folders not being analyzed"},{"location":"troubleshooting/#wrong-diagnosticslint","text":"clojure-lsp persist the external jars analysis in a .lsp/sqlite.db file, if you have issues with some specific feature, try to remove that file and restart the server. clojure-lsp use clj-kondo to lint and cache in a .clj-kondo/.cache dir, try to remove that file as well if you think it's not linting correctly If you have issues with macros, double check your clj-kondo config .","title":"Wrong diagnostics/lint"},{"location":"troubleshooting/#missing-add-require-on-code-actions-when-using-coc-and-neovim","text":"If you find, when executing the command (coc-codeaction-line) (or (coc-codeaction-selected) or (coc-codeaction-cursor) ), that you aren't getting back all of the code actions you might expect, please ensure that you have, in your coc-settings.json the line disableDiagnostics set to false or better yet, don't have the line there at all :-)","title":"Missing Add require... on code actions when using CoC and (neo)vim"},{"location":"troubleshooting/#macos","text":"In some version of MacOS, Apple restrict the binary to run, to fix that run: xattr -d com.apple.quarantine /path/to/clojure-lsp","title":"MacOS"}]}